<script>
  // Configuration from meta tags
  const CONFIG = {
    MIN_ADVANCE_DAYS: parseInt(
      document.querySelector('meta[name="min-advance-days"]')?.content || 60
    ),
    MAX_ADVANCE_DAYS: parseInt(
      document.querySelector('meta[name="max-advance-days"]')?.content || 120
    ),
    MAX_DAYS_PER_REQUEST: parseInt(
      document.querySelector('meta[name="max-days-per-request"]')?.content || 4
    ),
    REQUEST_TYPES: {
      REQ_DO: 'DO',
      PM_OFF: 'PM',
      AM_OFF: 'AM',
      FLIGHT: 'FL',
    },
  };

  // Global state
  let existingRequests = [];
  let selectedDates = [];
  let isSubmitting = false;

  // Calendar Management Class (Restored Original Logic)
  class CalendarManager {
    constructor() {
      this.today = new Date();
      this.minDate = this.addDays(this.today, CONFIG.MIN_ADVANCE_DAYS);
      this.maxDate = this.addDays(this.today, CONFIG.MAX_ADVANCE_DAYS);

      // Allow viewing past requests - start from 6 months before today
      this.viewMinDate = this.addDays(this.today, -180);
      // Allow viewing 1 month after request period
      this.viewMaxDate = this.addDays(this.maxDate, 30);

      // Start with middle month (October) in the center position
      const middleDate = new Date(
        (this.minDate.getTime() + this.maxDate.getTime()) / 2
      );
      this.currentViewStart = new Date(
        middleDate.getFullYear(),
        middleDate.getMonth() - 1, // Subtract 1 to show October as middle month
        1
      );
      this.monthsToShow = 3;
    }

    addDays(date, days) {
      const result = new Date(date);
      result.setDate(result.getDate() + days);
      return result;
    }

    getMonthsToDisplay() {
      const months = [];
      let current = new Date(this.currentViewStart);

      for (let i = 0; i < this.monthsToShow; i++) {
        months.push(new Date(current));
        current.setMonth(current.getMonth() + 1);
      }

      return months;
    }

    canNavigatePrevious() {
      const previousMonth = new Date(this.currentViewStart);
      previousMonth.setMonth(previousMonth.getMonth() - 1);
      const viewMinMonth = new Date(
        this.viewMinDate.getFullYear(),
        this.viewMinDate.getMonth(),
        1
      );
      return previousMonth >= viewMinMonth;
    }

    canNavigateNext() {
      const lastDisplayedMonth = new Date(this.currentViewStart);
      lastDisplayedMonth.setMonth(
        lastDisplayedMonth.getMonth() + this.monthsToShow - 1
      );
      const viewMaxMonth = new Date(
        this.viewMaxDate.getFullYear(),
        this.viewMaxDate.getMonth(),
        1
      );
      return lastDisplayedMonth < viewMaxMonth;
    }

    navigatePrevious() {
      if (this.canNavigatePrevious()) {
        this.currentViewStart.setMonth(this.currentViewStart.getMonth() - 1);
        this.generateCalendar();
        this.updateNavigationButtons();
      }
    }

    navigateNext() {
      if (this.canNavigateNext()) {
        this.currentViewStart.setMonth(this.currentViewStart.getMonth() + 1);
        this.generateCalendar();
        this.updateNavigationButtons();
      }
    }

    updateNavigationButtons() {
      const prevBtn = document.getElementById('prevMonthBtn');
      const nextBtn = document.getElementById('nextMonthBtn');
      const currentDisplay = document.getElementById('currentMonthDisplay');

      if (prevBtn) prevBtn.disabled = !this.canNavigatePrevious();
      if (nextBtn) nextBtn.disabled = !this.canNavigateNext();

      // Update current month display
      const months = this.getMonthsToDisplay();
      const startMonth = months[0].toLocaleDateString('en-US', {
        month: 'short',
        year: 'numeric',
      });
      const endMonth = months[months.length - 1].toLocaleDateString('en-US', {
        month: 'short',
        year: 'numeric',
      });
      if (currentDisplay) {
        currentDisplay.textContent = `${startMonth} - ${endMonth}`;
      }
    }

    isDateAvailable(date) {
      return date >= this.minDate && date <= this.maxDate;
    }

    isWeekend(date) {
      const day = date.getDay();
      return day === 0 || day === 6;
    }

    formatDate(date) {
      // DST-safe date formatting
      const utcDate = new Date(
        Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())
      );
      return utcDate.toISOString().split('T')[0];
    }

    generateCalendar() {
      const calendarGrid = document.getElementById('calendarGrid');
      if (!calendarGrid) {
        console.error('Calendar container not found!');
        return;
      }

      calendarGrid.innerHTML = '';

      const months = this.getMonthsToDisplay();

      months.forEach((monthStart) => {
        const monthContainer = this.createMonthContainer(monthStart);
        calendarGrid.appendChild(monthContainer);
      });

      this.updateNavigationButtons();
      this.updateDateSelection();
    }

    createMonthContainer(monthStart) {
      const monthContainer = document.createElement('div');
      monthContainer.className = 'month-container';

      // Month header
      const monthHeader = document.createElement('div');
      monthHeader.className = 'month-header';
      monthHeader.textContent = monthStart.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric',
      });

      // Weekday headers
      const weekdayHeader = document.createElement('div');
      weekdayHeader.className = 'weekday-header';
      ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].forEach((day) => {
        const dayElement = document.createElement('div');
        dayElement.className = 'weekday';
        dayElement.textContent = day;
        weekdayHeader.appendChild(dayElement);
      });

      // Days grid
      const daysGrid = document.createElement('div');
      daysGrid.className = 'days-grid';

      const firstDay = new Date(
        monthStart.getFullYear(),
        monthStart.getMonth(),
        1
      );
      const startDate = new Date(firstDay);
      let dayOfWeek = firstDay.getDay();
      dayOfWeek = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      startDate.setDate(startDate.getDate() - dayOfWeek);

      for (let i = 0; i < 42; i++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + i);
        const isCurrentMonth = currentDate.getMonth() === monthStart.getMonth();
        const dayCell = this.createDayCell(
          currentDate,
          monthStart,
          isCurrentMonth
        );
        daysGrid.appendChild(dayCell);
      }

      monthContainer.appendChild(monthHeader);
      monthContainer.appendChild(weekdayHeader);
      monthContainer.appendChild(daysGrid);

      return monthContainer;
    }

    createDayCell(date, monthStart, shouldShowDate) {
      const dayCell = document.createElement('div');
      dayCell.className = 'day-cell';
      dayCell.dataset.date = this.formatDate(date);

      if (!shouldShowDate) {
        dayCell.style.visibility = 'hidden';
        dayCell.style.pointerEvents = 'none';
        return dayCell;
      }

      const dayNumber = document.createElement('div');
      dayNumber.className = 'day-number';
      dayNumber.textContent = date.getDate();

      const isCurrentMonth = date.getMonth() === monthStart.getMonth();
      const isAvailable = this.isDateAvailable(date);
      const isWeekend = this.isWeekend(date);

      if (!isCurrentMonth) {
        dayCell.classList.add('other-month');
      }

      if (isWeekend) {
        dayCell.classList.add('weekend');
      }

      if (!isAvailable) {
        dayCell.classList.add('unavailable');
      } else {
        dayCell.addEventListener('click', () => this.handleDateClick(date));
      }

      // Check for existing requests
      const existingRequest = this.getExistingRequest(date);
      if (existingRequest) {
        const requestElement = document.createElement('div');
        requestElement.className = `day-request request-${existingRequest.status.toLowerCase()}`;
        requestElement.textContent = CONFIG.REQUEST_TYPES[existingRequest.type];

        dayCell.setAttribute('data-bs-toggle', 'tooltip');
        dayCell.setAttribute('data-bs-placement', 'top');
        dayCell.setAttribute(
          'title',
          `${this.formatDate(date)}: ${existingRequest.type} (${existingRequest.status})${
            existingRequest.customMessage
              ? ' - ' + existingRequest.customMessage
              : ''
          }`
        );

        dayCell.appendChild(requestElement);
      }

      dayCell.appendChild(dayNumber);
      return dayCell;
    }

    getExistingRequest(date) {
      const dateStr = this.formatDate(date);
      return existingRequests.find(
        (request) =>
          request.startDate === dateStr || request.endDate === dateStr
      );
    }

    handleDateClick(date) {
      if (!this.isDateAvailable(date)) return;

      const dateStr = this.formatDate(date);
      const existingRequest = this.getExistingRequest(date);

      if (existingRequest) {
        showToast(`Request already exists for ${dateStr}`, 'info');
        return;
      }

      const index = selectedDates.findIndex((d) => d.date === dateStr);

      if (index > -1) {
        // Deselecting - check if remaining dates stay consecutive
        const tempSelection = [...selectedDates];
        tempSelection.splice(index, 1);

        if (
          tempSelection.length > 1 &&
          !validateConsecutiveDates(tempSelection.map((d) => d.date))
        ) {
          showToast(
            'Removing this date would break consecutive selection. Starting fresh.',
            'warning'
          );
          selectedDates = [];
        } else {
          selectedDates.splice(index, 1);
        }
      } else {
        // Selecting new date
        if (selectedDates.length === 0) {
          selectedDates.push({ date: dateStr, type: 'REQ_DO' });
        } else {
          if (this.isConsecutiveToSelection(dateStr)) {
            if (selectedDates.length >= CONFIG.MAX_DAYS_PER_REQUEST) {
              showToast(
                `Maximum ${CONFIG.MAX_DAYS_PER_REQUEST} consecutive days allowed`,
                'warning'
              );
              return;
            }
            selectedDates.push({ date: dateStr, type: 'REQ_DO' });
          } else {
            selectedDates = [{ date: dateStr, type: 'REQ_DO' }];
            showToast('Started new selection', 'info');
          }
        }
      }

      selectedDates.sort((a, b) => new Date(a.date) - new Date(b.date));

      setTimeout(() => {
        this.updateDateSelection();
        this.updateFloatingButton();
      }, 10);
    }

    // DST-safe consecutive check
    isConsecutiveToSelection(newDateStr) {
      if (selectedDates.length === 0) return true;

      const selectedDateStrings = selectedDates.map((d) => d.date).sort();
      const allDates = [...selectedDateStrings, newDateStr].sort();

      for (let i = 1; i < allDates.length; i++) {
        const prevDate = allDates[i - 1];
        const currentDate = allDates[i];
        const expectedNext = addDays(prevDate, 1);
        if (currentDate !== expectedNext) {
          return false;
        }
      }

      return true;
    }

    updateDateSelection() {
      const allSelected = document.querySelectorAll('.day-cell.selected');
      allSelected.forEach((cell) => cell.classList.remove('selected'));

      selectedDates.forEach(({ date }) => {
        const cells = document.querySelectorAll(`[data-date="${date}"]`);
        cells.forEach((cell) => {
          if (cell.style.visibility !== 'hidden') {
            cell.classList.add('selected');
          }
        });
      });
    }

    updateFloatingButton() {
      const button = document.getElementById('createRequestBtn');
      const buttonText = document.getElementById('requestBtnText');

      if (selectedDates.length > 0) {
        button.classList.add('show');
        if (buttonText) {
          buttonText.textContent = `Create Request (${selectedDates.length} day${selectedDates.length > 1 ? 's' : ''})`;
        }
      } else {
        button.classList.remove('show');
        if (buttonText) {
          buttonText.textContent = 'New Request';
        }
      }
    }
  }

  // Initialize calendar
  const calendar = new CalendarManager();

  // DST-safe date utility
  function addDays(dateStr, days) {
    const parts = dateStr.split('-');
    const date = new Date(
      parseInt(parts[0]),
      parseInt(parts[1]) - 1,
      parseInt(parts[2])
    );
    date.setDate(date.getDate() + days);
    const utcDate = new Date(
      Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())
    );
    return utcDate.toISOString().split('T')[0];
  }

  // Enhanced consecutive date validation
  function validateConsecutiveDates(dates) {
    if (dates.length <= 1) return true;

    const sortedDates = [...dates].sort();
    for (let i = 1; i < sortedDates.length; i++) {
      const expectedDate = addDays(sortedDates[i - 1], 1);
      if (sortedDates[i] !== expectedDate) {
        return false;
      }
    }
    return true;
  }

  // API Functions
  async function loadExistingRequests() {
    try {
      const response = await fetch('/api/requests');
      const data = await response.json();

      if (data.success) {
        existingRequests = data.data;
        updateStatistics(data.data);
        calendar.generateCalendar();
        initializeTooltips();
      }
    } catch (error) {
      console.error('Error loading requests:', error);
      showToast('Failed to load existing requests', 'error');
    }
  }

  function updateStatistics(requests) {
    const pending = requests.filter((r) => r.status === 'PENDING').length;
    const approved = requests.filter((r) => r.status === 'APPROVED').length;
    const denied = requests.filter((r) => r.status === 'DENIED').length;

    document.getElementById('pendingCount').textContent = pending;
    document.getElementById('approvedCount').textContent = approved;
    document.getElementById('deniedCount').textContent = denied;
    document.getElementById('totalCount').textContent = requests.length;
  }

  function initializeTooltips() {
    const tooltipTriggerList = [].slice.call(
      document.querySelectorAll('[data-bs-toggle="tooltip"]')
    );
    tooltipTriggerList.map(
      (tooltipTriggerEl) => new bootstrap.Tooltip(tooltipTriggerEl)
    );
  }

  // Modal Functions
  function openGroupRequestModal() {
    if (selectedDates.length === 0) {
      showToast('Please select dates first', 'warning');
      return;
    }

    let modal = document.getElementById('groupRequestModal');
    if (!modal) {
      createGroupRequestModal();
      modal = document.getElementById('groupRequestModal');
    }

    populateModalDates();
    const bootstrapModal = new bootstrap.Modal(modal);
    bootstrapModal.show();
  }

  function createGroupRequestModal() {
    const modalHTML = `
    <div class="modal fade" id="groupRequestModal" tabindex="-1">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">
              <i class="bi bi-calendar-plus"></i> Create Time-Off Request
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <form id="groupRequestForm">
              <div class="mb-3">
                <label class="form-label">Selected Dates</label>
                <div id="selectedDatesList" class="border rounded p-3 bg-light">
                  <!-- Dates will be populated here -->
                </div>
              </div>
              
              <div class="mb-3">
                <label for="customMessage" class="form-label">Custom Message (Optional)</label>
                <textarea 
                  class="form-control" 
                  id="customMessage" 
                  rows="3" 
                  placeholder="Additional information or reason for time-off...">
                </textarea>
              </div>
              
              <div class="alert alert-info">
                <i class="bi bi-info-circle me-2"></i>
                <small>
                  Request will be sent to scheduling@tuifly.be for approval.
                </small>
              </div>
            </form>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-primary" id="submitGroupRequest">
              <i class="bi bi-send me-1"></i>Submit Request
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
    document.body.insertAdjacentHTML('beforeend', modalHTML);
  }

  function populateModalDates() {
    const container = document.getElementById('selectedDatesList');
    container.innerHTML = '';

    selectedDates.forEach((dateObj, index) => {
      const date = new Date(dateObj.date);
      const dateStr = date.toLocaleDateString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      });

      const dateRow = document.createElement('div');
      dateRow.className = 'row mb-2 align-items-center';
      const isFlightType = dateObj.type === 'FLIGHT';

      dateRow.innerHTML = `
        <div class="col-md-6">
          <span class="fw-bold">${dateStr}</span>
        </div>
        <div class="col-md-4">
          <select class="form-select form-select-sm" onchange="updateDateType(${index}, this.value)">
            <option value="REQ_DO" ${dateObj.type === 'REQ_DO' ? 'selected' : ''}>Full Day Off</option>
            <option value="PM_OFF" ${dateObj.type === 'PM_OFF' ? 'selected' : ''}>PM Off</option>
            <option value="AM_OFF" ${dateObj.type === 'AM_OFF' ? 'selected' : ''}>AM Off</option>
            <option value="FLIGHT" ${dateObj.type === 'FLIGHT' ? 'selected' : ''}>Flight</option>
          </select>
        </div>
        <div class="col-md-2">
          <input 
            type="text" 
            class="form-control form-control-sm" 
            placeholder="TB###"
            value="${dateObj.flightNumber || ''}"
            ${isFlightType ? '' : 'style="display:none;" disabled'}
            onchange="updateFlightNumber(${index}, this.value)"
            id="flight-${index}"
          />
        </div>
      `;

      container.appendChild(dateRow);
    });
  }

  function updateDateType(index, type) {
    selectedDates[index].type = type;

    const flightInput = document.getElementById(`flight-${index}`);
    if (type === 'FLIGHT') {
      flightInput.style.display = 'block';
      flightInput.disabled = false;
      flightInput.required = true;
      flightInput.focus();
    } else {
      flightInput.style.display = 'none';
      flightInput.disabled = true;
      flightInput.required = false;
      selectedDates[index].flightNumber = '';
    }
  }

  function updateFlightNumber(index, flightNumber) {
    selectedDates[index].flightNumber = flightNumber;
  }

  async function submitGroupRequest() {
    if (isSubmitting) return;

    const customMessage = document.getElementById('customMessage').value.trim();
    const submitButton = document.getElementById('submitGroupRequest');

    // Validate flight numbers
    const flightDates = selectedDates.filter((d) => d.type === 'FLIGHT');
    for (const date of flightDates) {
      if (!date.flightNumber || !date.flightNumber.startsWith('TB')) {
        showToast('Flight numbers must start with "TB"', 'error');
        return;
      }
    }

    if (!validateConsecutiveDates(selectedDates.map((d) => d.date))) {
      showToast('Selected dates must be consecutive', 'error');
      return;
    }

    if (selectedDates.length === 0) return;

    isSubmitting = true;
    submitButton.disabled = true;
    submitButton.innerHTML =
      '<i class="bi bi-hourglass-split me-1"></i>Submitting...';

    try {
      const response = await fetch('/api/requests/group', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          dates: selectedDates,
          customMessage: customMessage || null,
        }),
      });

      const result = await response.json();

      if (result.success) {
        const modal = bootstrap.Modal.getInstance(
          document.getElementById('groupRequestModal')
        );
        modal.hide();

        selectedDates = [];
        calendar.updateDateSelection();
        calendar.updateFloatingButton();

        await loadExistingRequests();
        showToast(result.message, 'success');
      } else {
        showToast(result.error, 'error');
      }
    } catch (error) {
      console.error('Error creating group request:', error);
      showToast('Failed to create request', 'error');
    } finally {
      isSubmitting = false;
      submitButton.disabled = false;
      submitButton.innerHTML = '<i class="bi bi-send me-1"></i>Submit Request';
    }
  }

  // Event Listeners
  document.addEventListener('DOMContentLoaded', async () => {
    await loadExistingRequests();

    const createBtn = document.getElementById('createRequestBtn');
    if (createBtn && !createBtn.hasAttribute('data-listener-added')) {
      createBtn.addEventListener('click', openGroupRequestModal);
      createBtn.setAttribute('data-listener-added', 'true');
    }

    const prevBtn = document.getElementById('prevMonthBtn');
    const nextBtn = document.getElementById('nextMonthBtn');

    if (prevBtn && !prevBtn.hasAttribute('data-listener-added')) {
      prevBtn.addEventListener('click', () => calendar.navigatePrevious());
      prevBtn.setAttribute('data-listener-added', 'true');
    }

    if (nextBtn && !nextBtn.hasAttribute('data-listener-added')) {
      nextBtn.addEventListener('click', () => calendar.navigateNext());
      nextBtn.setAttribute('data-listener-added', 'true');
    }

    document.addEventListener('click', (e) => {
      if (e.target.id === 'submitGroupRequest') {
        e.preventDefault();
        submitGroupRequest();
      }
    });

    document.addEventListener('hidden.bs.modal', (e) => {
      if (e.target.id === 'groupRequestModal') {
        document.getElementById('groupRequestForm')?.reset();
        const customMessage = document.getElementById('customMessage');
        if (customMessage) customMessage.value = '';
        isSubmitting = false;
      }
    });
  });

  // Toast notification function
  function showToast(message, type = 'info') {
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.className =
        'toast-container position-fixed top-0 end-0 p-3';
      toastContainer.style.zIndex = '1055';
      document.body.appendChild(toastContainer);
    }

    const toastId = 'toast_' + Date.now();
    const bgClass =
      type === 'success'
        ? 'bg-success'
        : type === 'error'
          ? 'bg-danger'
          : type === 'warning'
            ? 'bg-warning'
            : 'bg-info';

    const toastHTML = `
      <div id="${toastId}" class="toast ${bgClass} text-white" role="alert">
        <div class="d-flex">
          <div class="toast-body">${message}</div>
          <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
        </div>
      </div>
    `;

    toastContainer.insertAdjacentHTML('beforeend', toastHTML);

    const toastElement = document.getElementById(toastId);
    const toast = new bootstrap.Toast(toastElement, {
      autohide: true,
      delay: type === 'error' ? 5000 : 3000,
    });
    toast.show();

    toastElement.addEventListener('hidden.bs.toast', () => {
      toastElement.remove();
    });
  }
</script>
