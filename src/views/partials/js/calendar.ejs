<script>
  // Configuration from meta tags
  const CONFIG = {
    MIN_ADVANCE_DAYS: parseInt(
      document.querySelector('meta[name="min-advance-days"]')?.content || 60
    ),
    MAX_ADVANCE_DAYS: parseInt(
      document.querySelector('meta[name="max-advance-days"]')?.content || 120
    ),
    MAX_DAYS_PER_REQUEST: parseInt(
      document.querySelector('meta[name="max-days-per-request"]')?.content || 4
    ),
    REQUEST_TYPES: {
      REQ_DO: 'DO',
      PM_OFF: 'PM',
      AM_OFF: 'AM',
      FLIGHT: 'FL',
    },
  };

  // Global state
  let existingRequests = [];
  let selectedDates = [];
  let isSubmitting = false;
  let currentUserData = null;
  async function loadUserDataAndSettings() {
    try {
      const response = await fetch('/settings/api');
      const data = await response.json();
      if (data.success) {
        // Load user data
        currentUserData = data.data.user;
        window.currentUserData = currentUserData; // Make it globally available

        // Load email preference
        userEmailPreference = data.data.user.emailPreference || 'automatic';

        console.log('User data loaded:', currentUserData);
        console.log('User email preference:', userEmailPreference);
      }
    } catch (error) {
      console.error('Failed to load user data and settings:', error);
      // Default to automatic if we can't load settings
      userEmailPreference = 'automatic';
    }
  }
  // Calendar Management Class (Restored Original Logic)
  class CalendarManager {
    constructor() {
      this.today = new Date();
      this.minDate = this.addDays(this.today, CONFIG.MIN_ADVANCE_DAYS);
      this.maxDate = this.addDays(this.today, CONFIG.MAX_ADVANCE_DAYS);

      // Allow viewing past requests - start from 6 months before today
      this.viewMinDate = this.addDays(this.today, -180);
      // Allow viewing 1 month after request period
      this.viewMaxDate = this.addDays(this.maxDate, 30);

      // Start with middle month (October) in the center position
      const middleDate = new Date(
        (this.minDate.getTime() + this.maxDate.getTime()) / 2
      );
      this.currentViewStart = new Date(
        middleDate.getFullYear(),
        middleDate.getMonth() - 1, // Subtract 1 to show October as middle month
        1
      );
      this.monthsToShow = 3;
    }

    addDays(date, days) {
      const result = new Date(date);
      result.setDate(result.getDate() + days);
      return result;
    }

    getMonthsToDisplay() {
      const months = [];
      let current = new Date(this.currentViewStart);

      for (let i = 0; i < this.monthsToShow; i++) {
        months.push(new Date(current));
        current.setMonth(current.getMonth() + 1);
      }

      return months;
    }

    canNavigatePrevious() {
      const previousMonth = new Date(this.currentViewStart);
      previousMonth.setMonth(previousMonth.getMonth() - 1);
      const viewMinMonth = new Date(
        this.viewMinDate.getFullYear(),
        this.viewMinDate.getMonth(),
        1
      );
      return previousMonth >= viewMinMonth;
    }

    canNavigateNext() {
      const lastDisplayedMonth = new Date(this.currentViewStart);
      lastDisplayedMonth.setMonth(
        lastDisplayedMonth.getMonth() + this.monthsToShow - 1
      );
      const viewMaxMonth = new Date(
        this.viewMaxDate.getFullYear(),
        this.viewMaxDate.getMonth(),
        1
      );
      return lastDisplayedMonth < viewMaxMonth;
    }

    navigatePrevious() {
      if (this.canNavigatePrevious()) {
        this.currentViewStart.setMonth(this.currentViewStart.getMonth() - 1);
        this.generateCalendar();
        this.updateNavigationButtons();
      }
    }

    navigateNext() {
      if (this.canNavigateNext()) {
        this.currentViewStart.setMonth(this.currentViewStart.getMonth() + 1);
        this.generateCalendar();
        this.updateNavigationButtons();
      }
    }

    updateNavigationButtons() {
      const prevBtn = document.getElementById('prevMonthBtn');
      const nextBtn = document.getElementById('nextMonthBtn');
      const currentDisplay = document.getElementById('currentMonthDisplay');

      if (prevBtn) prevBtn.disabled = !this.canNavigatePrevious();
      if (nextBtn) nextBtn.disabled = !this.canNavigateNext();

      // Update current month display
      const months = this.getMonthsToDisplay();
      const startMonth = months[0].toLocaleDateString('en-US', {
        month: 'short',
        year: 'numeric',
      });
      const endMonth = months[months.length - 1].toLocaleDateString('en-US', {
        month: 'short',
        year: 'numeric',
      });
      if (currentDisplay) {
        currentDisplay.textContent = `${startMonth} - ${endMonth}`;
      }
    }

    isDateAvailable(date) {
      return date >= this.minDate && date <= this.maxDate;
    }

    isWeekend(date) {
      const day = date.getDay();
      return day === 0 || day === 6;
    }

    formatDate(date) {
      // DST-safe date formatting
      const utcDate = new Date(
        Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())
      );
      return utcDate.toISOString().split('T')[0];
    }

    generateCalendar() {
      const calendarGrid = document.getElementById('calendarGrid');
      if (!calendarGrid) {
        console.error('Calendar container not found!');
        return;
      }

      calendarGrid.innerHTML = '';

      const months = this.getMonthsToDisplay();

      months.forEach((monthStart) => {
        const monthContainer = this.createMonthContainer(monthStart);
        calendarGrid.appendChild(monthContainer);
      });

      this.updateNavigationButtons();
      this.updateDateSelection();
    }

    createMonthContainer(monthStart) {
      const monthContainer = document.createElement('div');
      monthContainer.className = 'month-container';

      // Month header
      const monthHeader = document.createElement('div');
      monthHeader.className = 'month-header';
      monthHeader.textContent = monthStart.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric',
      });

      // Weekday headers
      const weekdayHeader = document.createElement('div');
      weekdayHeader.className = 'weekday-header';
      ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].forEach((day) => {
        const dayElement = document.createElement('div');
        dayElement.className = 'weekday';
        dayElement.textContent = day;
        weekdayHeader.appendChild(dayElement);
      });

      // Days grid
      const daysGrid = document.createElement('div');
      daysGrid.className = 'days-grid';

      const firstDay = new Date(
        monthStart.getFullYear(),
        monthStart.getMonth(),
        1
      );
      const startDate = new Date(firstDay);
      let dayOfWeek = firstDay.getDay();
      dayOfWeek = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      startDate.setDate(startDate.getDate() - dayOfWeek);

      for (let i = 0; i < 42; i++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + i);
        const isCurrentMonth = currentDate.getMonth() === monthStart.getMonth();
        const dayCell = this.createDayCell(
          currentDate,
          monthStart,
          isCurrentMonth
        );
        daysGrid.appendChild(dayCell);
      }

      monthContainer.appendChild(monthHeader);
      monthContainer.appendChild(weekdayHeader);
      monthContainer.appendChild(daysGrid);

      return monthContainer;
    }

    createDayCell(date, monthStart, shouldShowDate) {
      const dayCell = document.createElement('div');
      dayCell.className = 'day-cell';
      dayCell.dataset.date = this.formatDate(date);

      if (!shouldShowDate) {
        dayCell.style.visibility = 'hidden';
        dayCell.style.pointerEvents = 'none';
        return dayCell;
      }

      // Day number
      const dayNumber = document.createElement('div');
      dayNumber.className = 'day-number';
      dayNumber.textContent = date.getDate();

      // Determine cell state
      const isCurrentMonth = date.getMonth() === monthStart.getMonth();
      const isAvailable = this.isDateAvailable(date);
      const isWeekend = this.isWeekend(date);

      if (!isCurrentMonth) {
        dayCell.classList.add('other-month');
      }

      if (isWeekend) {
        dayCell.classList.add('weekend');
      }

      if (!isAvailable) {
        dayCell.classList.add('unavailable');
      } else {
        // Add click handler for both new requests AND existing requests
        dayCell.addEventListener('click', () => this.handleDateClick(date));
      }

      // Check for existing requests
      const existingRequest = this.getExistingRequest(date);
      if (existingRequest) {
        const requestElement = document.createElement('div');
        requestElement.className = `day-request request-${existingRequest.status.toLowerCase()}`;

        // Create request content container
        const requestContent = document.createElement('div');
        requestContent.className = 'request-content';

        // Create request type span
        const requestType = document.createElement('span');
        requestType.className = 'request-type';
        requestType.textContent = CONFIG.REQUEST_TYPES[existingRequest.type];

        // Create email status icon span with LARGER size
        const emailStatusIcon = document.createElement('span');
        emailStatusIcon.className = 'email-status-icon';

        // Get CORRECT email status icon based on user preference and request data
        const emailStatus = this.getEmailStatusIcon(existingRequest);
        emailStatusIcon.textContent = emailStatus.icon;
        emailStatusIcon.setAttribute('title', emailStatus.title);

        // Append elements
        requestContent.appendChild(requestType);
        requestContent.appendChild(emailStatusIcon);
        requestElement.appendChild(requestContent);

        // Add tooltip for the entire request
        dayCell.setAttribute('data-bs-toggle', 'tooltip');
        dayCell.setAttribute('data-bs-placement', 'top');
        dayCell.setAttribute(
          'title',
          `${this.formatDate(date)}: ${existingRequest.type} (${existingRequest.status}) - ${emailStatus.title}${
            existingRequest.customMessage
              ? ' - ' + existingRequest.customMessage // âœ… Make sure this line is complete
              : ''
          }`
        );
        const modeIndicator = document.createElement('span');
        modeIndicator.className = 'email-mode-indicator';
        modeIndicator.textContent =
          existingRequest.emailMode === 'automatic' ? 'ðŸ¤–' : 'ðŸ“§';
        modeIndicator.title = `Created in ${existingRequest.emailMode || 'manual'} email mode`;
        modeIndicator.style.fontSize = '10px';
        modeIndicator.style.opacity = '0.7';
        requestElement.appendChild(modeIndicator);

        dayCell.appendChild(requestElement);
      }

      dayCell.appendChild(dayNumber);
      return dayCell;
    }

    // Add this helper method to CalendarManager class
    // âœ… UPDATE: Existing getEmailStatusIcon function in CalendarManager class
    getEmailStatusIcon(request) {
      // Use the request's original emailMode, not the user's current preference
      const requestEmailMode = request.emailMode || 'manual';

      if (requestEmailMode === 'automatic') {
        if (request.emailSent) {
          return {
            icon: 'âœ…',
            title: 'Email sent automatically',
          };
        } else if (request.emailFailed) {
          return {
            icon: 'âŒ',
            title: 'Email failed to send',
          };
        } else if (request.emailPending) {
          return {
            icon: 'ðŸ”„',
            title: 'Email sending in progress',
          };
        } else {
          return {
            icon: 'âš ï¸',
            title: 'Email not sent yet',
          };
        }
      } else {
        // Manual mode: Check manual confirmation status
        if (request.manualEmailConfirmed) {
          return {
            icon: 'âœ…',
            title: 'User confirmed email sent',
          };
        } else if (
          request.manualEmailContent &&
          !request.manualEmailConfirmed
        ) {
          return {
            icon: 'ðŸ“§',
            title: 'Email ready to copy and send',
          };
        } else {
          return {
            icon: 'âš ï¸',
            title: 'Email not prepared yet',
          };
        }
      }
    }

    // Alternative simpler version if the above is too complex:
    getEmailStatusIconSimple(request) {
      // Simple fallback that works with current data structure
      if (request.status === 'APPROVED') {
        return {
          icon: 'âœ…',
          title: 'Request approved',
        };
      } else if (request.status === 'DENIED') {
        return {
          icon: 'âŒ',
          title: 'Request denied',
        };
      } else {
        return {
          icon: 'ðŸ“§',
          title: 'Request pending',
        };
      }
    }

    getExistingRequest(date) {
      const dateStr = this.formatDate(date);
      return existingRequests.find(
        (request) =>
          request.startDate === dateStr || request.endDate === dateStr
      );
    }

    handleDateClick(date) {
      if (!this.isDateAvailable(date)) return;

      const dateStr = this.formatDate(date);
      const existingRequest = this.getExistingRequest(date);

      if (existingRequest) {
        this.openRequestDetailModal(existingRequest, dateStr);
        return; // OPENS MODAL INSTEAD!
      }

      const index = selectedDates.findIndex((d) => d.date === dateStr);

      if (index > -1) {
        // Deselecting - check if remaining dates stay consecutive
        const tempSelection = [...selectedDates];
        tempSelection.splice(index, 1);

        if (
          tempSelection.length > 1 &&
          !validateConsecutiveDates(tempSelection.map((d) => d.date))
        ) {
          showToast(
            'Removing this date would break consecutive selection. Starting fresh.',
            'warning'
          );
          selectedDates = [];
        } else {
          selectedDates.splice(index, 1);
        }
      } else {
        // Selecting new date
        if (selectedDates.length === 0) {
          selectedDates.push({ date: dateStr, type: 'REQ_DO' });
        } else {
          if (this.isConsecutiveToSelection(dateStr)) {
            if (selectedDates.length >= CONFIG.MAX_DAYS_PER_REQUEST) {
              showToast(
                `Maximum ${CONFIG.MAX_DAYS_PER_REQUEST} consecutive days allowed`,
                'warning'
              );
              return;
            }
            selectedDates.push({ date: dateStr, type: 'REQ_DO' });
          } else {
            selectedDates = [{ date: dateStr, type: 'REQ_DO' }];
            showToast('Started new selection', 'info');
          }
        }
      }

      selectedDates.sort((a, b) => new Date(a.date) - new Date(b.date));

      setTimeout(() => {
        this.updateDateSelection();
        this.updateFloatingButton();
      }, 10);
    }

    // DST-safe consecutive check
    isConsecutiveToSelection(newDateStr) {
      if (selectedDates.length === 0) return true;

      const selectedDateStrings = selectedDates.map((d) => d.date).sort();
      const allDates = [...selectedDateStrings, newDateStr].sort();

      for (let i = 1; i < allDates.length; i++) {
        const prevDate = allDates[i - 1];
        const currentDate = allDates[i];
        const expectedNext = addDays(prevDate, 1);
        if (currentDate !== expectedNext) {
          return false;
        }
      }

      return true;
    }

    updateDateSelection() {
      const allSelected = document.querySelectorAll('.day-cell.selected');
      allSelected.forEach((cell) => cell.classList.remove('selected'));

      selectedDates.forEach(({ date }) => {
        const cells = document.querySelectorAll(`[data-date="${date}"]`);
        cells.forEach((cell) => {
          if (cell.style.visibility !== 'hidden') {
            cell.classList.add('selected');
          }
        });
      });
    }

    updateFloatingButton() {
      const button = document.getElementById('createRequestBtn');
      const buttonText = document.getElementById('requestBtnText');

      if (selectedDates.length > 0) {
        button.classList.add('show');
        if (buttonText) {
          buttonText.textContent = `Create Request (${selectedDates.length} day${selectedDates.length > 1 ? 's' : ''})`;
        }
      } else {
        button.classList.remove('show');
        if (buttonText) {
          buttonText.textContent = 'New Request';
        }
      }
    }
    openRequestDetailModal(request, dateStr) {
      const existingModal = document.getElementById('requestDetailModal');
      if (existingModal) {
        existingModal.remove();
      }

      // âœ… For group requests, get the full date range
      let dateRangeDisplay;
      if (request.groupId) {
        // Find all requests in the same group to show full range
        const groupRequests = existingRequests.filter(
          (r) => r.groupId === request.groupId
        );
        if (groupRequests.length > 1) {
          groupRequests.sort(
            (a, b) => new Date(a.startDate) - new Date(b.startDate)
          );
          const firstDate = groupRequests[0].startDate;
          const lastDate = groupRequests[groupRequests.length - 1].endDate;
          dateRangeDisplay = `${firstDate} to ${lastDate} (${groupRequests.length} days)`;
        } else {
          dateRangeDisplay = `${request.startDate} to ${request.endDate}`;
        }
      } else {
        dateRangeDisplay = `${request.startDate} to ${request.endDate}`;
      }

      const modalHTML = `
    <div class="modal fade" id="requestDetailModal" tabindex="-1">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">
              <i class="bi bi-calendar-event"></i> Request Details - ${dateStr}
              ${request.groupId ? ' <span class="badge bg-info">Group Request</span>' : ''}
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <div class="row">
              <div class="col-md-6">
                <h6><i class="bi bi-info-circle me-2"></i>Request Information</h6>
                <p><strong>Type:</strong> ${CONFIG.REQUEST_TYPES[request.type]}</p>
                <p><strong>Status:</strong> <span class="badge bg-${this.getStatusColor(request.status)}">${request.status}</span></p>
                <p><strong>Date Range:</strong> ${dateRangeDisplay}</p>
                ${request.flightNumber ? `<p><strong>Flight:</strong> ${request.flightNumber}</p>` : ''}
                ${request.customMessage ? `<p><strong>Message:</strong> ${request.customMessage}</p>` : ''}
              </div>
              <div class="col-md-6">
                <h6><i class="bi bi-envelope me-2"></i>Email Information</h6>
                ${this.getEmailInfoSection(request)}
              </div>
            </div>

           ${this.getManualEmailSection(request)}
          </div>
          <div class="modal-footer">
            ${this.getModalActions(request)}
          </div>
        </div>
      </div>
    </div>
  `;

      document.body.insertAdjacentHTML('beforeend', modalHTML);
      const modal = new bootstrap.Modal(
        document.getElementById('requestDetailModal')
      );
      modal.show();

      // Setup modal event listeners
      this.setupModalEventListeners(request);
    }

    getStatusColor(status) {
      switch (status) {
        case 'APPROVED':
          return 'success';
        case 'DENIED':
          return 'danger';
        default:
          return 'warning';
      }
    }

    getEmailInfoSection(request) {
      const emailStatus = this.getEmailStatusIcon(request);

      // âœ… Use userEmailPreference (current user setting) instead of request.emailMode
      const currentEmailMode = userEmailPreference || 'manual';

      if (currentEmailMode === 'automatic') {
        return `
      <p><strong>Email Mode:</strong> Automatic</p>
      <p><strong>Status:</strong> ${emailStatus.icon} ${emailStatus.title}</p>
      ${request.emailSent ? `<p><strong>Sent:</strong> ${new Date(request.emailSent).toLocaleString()}</p>` : ''}
    `;
      } else {
        return `
      <p><strong>Email Mode:</strong> Manual</p>
      <p><strong>Status:</strong> ${emailStatus.icon} ${emailStatus.title}</p>
      ${request.manualEmailConfirmed ? `<p><strong>Confirmed Sent:</strong> Yes</p>` : ''}
    `;
      }
    }

    getManualEmailSection(request) {
      if (userEmailPreference !== 'manual') {
        return '';
      }

      // If email already marked as sent, don't show email content section
      if (request.manualEmailConfirmed) {
        return `
    <div class="mt-4">
      <div class="alert alert-success">
        <i class="bi bi-check-circle me-2"></i>
        <strong>Email Confirmed Sent</strong><br>
        You have already confirmed that this email was sent manually.
      </div>
    </div>
  `;
      }

      // âœ… Generate email content (works for both single and group requests)
      let emailContent;
      if (request.groupId) {
        // For group requests, generate group email content
        emailContent = this.generateGroupEmailContent(request);
      } else {
        // For single requests, use existing function
        emailContent = this.generateEmailContent(request);
      }

      return `
  <div class="mt-4">
    <h6>
      <i class="bi bi-envelope-plus me-2"></i>
      Email Content to Copy ${request.groupId ? '(Group Request)' : ''}
    </h6>
    <div class="card bg-light">
      <div class="card-body">
        <div class="email-field mb-2">
          <label class="fw-bold">To:</label>
          <div class="input-group input-group-sm">
            <input type="text" class="form-control" value="scheduling@tuifly.be" readonly id="emailTo">
            <button class="btn btn-outline-secondary copy-btn" type="button" onclick="copyToClipboard('emailTo')">
              <i class="bi bi-clipboard"></i> Copy
            </button>
          </div>
        </div>
        <div class="email-field mb-2">
          <label class="fw-bold">Subject:</label>
          <div class="input-group input-group-sm">
            <input type="text" class="form-control" value="${emailContent.subject}" readonly id="emailSubject">
            <button class="btn btn-outline-secondary copy-btn" type="button" onclick="copyToClipboard('emailSubject')">
              <i class="bi bi-clipboard"></i> Copy
            </button>
          </div>
        </div>
        <div class="email-field mb-3">
          <label class="fw-bold">Body:</label>
          <div class="input-group">
            <textarea class="form-control" rows="8" readonly id="emailBody">${emailContent.body}</textarea>
            <button class="btn btn-outline-secondary copy-btn" type="button" onclick="copyToClipboard('emailBody')">
              <i class="bi bi-clipboard"></i> Copy
            </button>
          </div>
        </div>
        
        <div class="text-center">
          <button class="btn btn-success" onclick="markEmailAsSent(${request.id})">
            <i class="bi bi-check-circle me-1"></i>Mark as Sent
          </button>
        </div>
      </div>
    </div>
  </div>
`;
    }
    generateGroupEmailContent(request) {
      // Get all requests in the same group
      const groupRequests = existingRequests.filter(
        (r) => r.groupId === request.groupId
      );
      groupRequests.sort(
        (a, b) => new Date(a.startDate) - new Date(b.startDate)
      );

      const firstDate = new Date(groupRequests[0].startDate);
      const month = firstDate.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric',
      });

      // Build the email body
      let bodyLines = ['Dear,', ''];

      groupRequests.forEach((req) => {
        let line = `${req.startDate} - `;

        // Convert type to display format
        switch (req.type) {
          case 'REQ_DO':
            line += 'REQ DO';
            break;
          case 'PM_OFF':
            line += 'PM OFF';
            break;
          case 'AM_OFF':
            line += 'AM OFF';
            break;
          case 'FLIGHT':
            line += 'FLIGHT';
            break;
          default:
            line += req.type;
        }

        if (req.flightNumber) {
          line += ` ${req.flightNumber}`;
        }
        bodyLines.push(line);
      });

      if (request.customMessage) {
        bodyLines.push('');
        bodyLines.push(request.customMessage);
        bodyLines.push(''); // Extra line break after custom message
      }

      bodyLines.push('');
      bodyLines.push(window.currentUserData?.signature || 'Brgds,\nYour Name');

      return {
        subject: `${window.currentUserData?.code || 'RVB'} - CREW REQUEST - ${month}`,
        body: bodyLines.join('\n'),
      };
    }

    generateEmailContent(request) {
      const startDate = new Date(request.startDate);
      const month = startDate.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric',
      });

      // Build the email body properly
      let bodyLines = ['Dear,', ''];

      // Add the actual request line with proper type display
      let line = `${request.startDate} - `;

      // Convert type to display format
      switch (request.type) {
        case 'REQ_DO':
          line += 'REQ DO';
          break;
        case 'PM_OFF':
          line += 'PM OFF';
          break;
        case 'AM_OFF':
          line += 'AM OFF';
          break;
        case 'FLIGHT':
          line += 'FLIGHT';
          break;
        default:
          line += request.type;
      }

      // Add flight number if exists
      if (request.flightNumber) {
        line += ` ${request.flightNumber}`;
      }

      bodyLines.push(line);

      // Add custom message if exists
      if (request.customMessage) {
        bodyLines.push('');
        bodyLines.push(request.customMessage);
        bodyLines.push(''); // âœ… ADD THIS: Additional line break after custom message
      }

      // ðŸ”¥ FIX: Add signature WITHOUT extra "Brgds" prefix
      bodyLines.push('');
      bodyLines.push(window.currentUserData?.signature || 'Brgds,\nYour Name');

      return {
        subject: `${window.currentUserData?.code || 'RVB'} - CREW REQUEST - ${month}`,
        body: bodyLines.join('\n'),
      };
    }

    getModalActions(request) {
      let actions = '';

      // Mark as sent button (only for manual mode and not yet confirmed)
      if (userEmailPreference === 'manual' && !request.manualEmailConfirmed) {
        actions += `
      <button type="button" class="btn btn-success" onclick="markEmailAsSent(${request.id})">
        <i class="bi bi-check-lg me-1"></i>Mark as Sent
      </button>
    `;
      }

      // Resend button (only for automatic mode and email failed)
      if (userEmailPreference === 'automatic' && request.emailFailed) {
        actions += `
      <button type="button" class="btn btn-warning me-2" onclick="resendEmail(${request.id})">
        <i class="bi bi-arrow-repeat me-1"></i>Resend Email
      </button>
    `;
      }

      // Delete button - only show if request is pending AND email not sent
      const canDelete =
        request.status === 'PENDING' &&
        ((userEmailPreference === 'automatic' && !request.emailSent) ||
          (userEmailPreference === 'manual' && !request.manualEmailConfirmed));

      if (canDelete) {
        // âœ… Use proper onclick with group detection
        const isGroup = request.groupId ? true : false;
        const deleteText = isGroup ? 'Delete Group' : 'Delete';

        actions += `
      <button type="button" class="btn btn-outline-danger me-2" onclick="deleteRequest(${request.id}, ${isGroup})">
        <i class="bi bi-trash me-1"></i>${deleteText}
      </button>
    `;
      }

      // Close button (always visible)
      actions += `
    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
      <i class="bi bi-x-lg me-1"></i>Close
    </button>
  `;

      return actions;
    }

    setupModalEventListeners(request) {
      // ðŸ”¥ COMPLETELY REWRITTEN copy button functionality
      document.querySelectorAll('.copy-btn').forEach((btn) => {
        btn.addEventListener('click', (e) => {
          e.preventDefault(); // Prevent any default behavior

          const targetId = e.currentTarget.getAttribute('data-copy');
          const targetElement = document.getElementById(targetId);

          console.log('Copy button clicked:', targetId, targetElement); // Debug log

          if (!targetElement) {
            console.error('Copy target element not found:', targetId);
            showToast('Copy failed - element not found', 'error');
            return;
          }

          let textToCopy = '';

          // Get text based on element type
          if (targetElement.tagName === 'INPUT') {
            textToCopy = targetElement.value;
          } else if (targetElement.tagName === 'TEXTAREA') {
            textToCopy = targetElement.value;
          } else {
            textToCopy = targetElement.textContent || targetElement.innerText;
          }

          console.log('Text to copy:', textToCopy); // Debug log

          if (!textToCopy) {
            showToast('Nothing to copy', 'warning');
            return;
          }

          // Copy to clipboard
          copyToClipboard(textToCopy, e.currentTarget);
        });
      });

      // Copy to clipboard function
      function copyToClipboard(text, button) {
        if (navigator.clipboard && window.isSecureContext) {
          // Modern clipboard API
          navigator.clipboard
            .writeText(text)
            .then(() => {
              showCopySuccess(button);
            })
            .catch((err) => {
              console.error('Clipboard API failed:', err);
              fallbackCopy(text, button);
            });
        } else {
          // Fallback for older browsers
          fallbackCopy(text, button);
        }
      }

      // Fallback copy method
      function fallbackCopy(text, button) {
        const tempTextarea = document.createElement('textarea');
        tempTextarea.value = text;
        tempTextarea.style.position = 'absolute';
        tempTextarea.style.left = '-9999px';
        tempTextarea.style.top = '-9999px';
        document.body.appendChild(tempTextarea);

        try {
          tempTextarea.select();
          tempTextarea.setSelectionRange(0, 99999);
          const success = document.execCommand('copy');

          if (success) {
            showCopySuccess(button);
          } else {
            showToast('Copy failed - please copy manually', 'error');
          }
        } catch (err) {
          console.error('Fallback copy failed:', err);
          showToast('Copy failed - please copy manually', 'error');
        } finally {
          document.body.removeChild(tempTextarea);
        }
      }

      // ðŸ”¥ FIX: Copy success feedback (2 seconds)
      function showCopySuccess(button) {
        if (!button) {
          console.error('No button provided to showCopySuccess');
          return;
        }

        console.log('Showing copy success feedback'); // Debug log

        const originalText = button.innerHTML;
        button.innerHTML = '<i class="bi bi-check"></i> Copied!';
        button.classList.add('btn-success');
        button.classList.remove('btn-outline-secondary');

        // Show toast notification
        showToast('Copied to clipboard!', 'success');

        // Revert button after 2 seconds
        setTimeout(() => {
          if (button && button.parentNode) {
            // Check if button still exists
            button.innerHTML = originalText;
            button.classList.remove('btn-success');
            button.classList.add('btn-outline-secondary');
          }
        }, 2000);
      }

      // Mark as sent functionality
      const markSentBtn = document.getElementById('markEmailSent');
      if (markSentBtn) {
        markSentBtn.addEventListener('click', async () => {
          try {
            const response = await fetch(
              `/api/requests/${request.id}/mark-email-sent`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
              }
            );

            const result = await response.json();
            if (result.success) {
              showToast(result.message, 'success');

              // Close modal and refresh calendar
              const modal = bootstrap.Modal.getInstance(
                document.getElementById('requestDetailModal')
              );
              modal.hide();
              await loadExistingRequests();
            } else {
              showToast(
                result.error || 'Failed to mark email as sent',
                'error'
              );
            }
          } catch (error) {
            console.error('Error marking email as sent:', error);
            showToast('Failed to mark email as sent', 'error');
          }
        });
      }

      // ðŸ”¥ ADD: Delete functionality
      const deleteBtn = document.getElementById('deleteRequest');
      if (deleteBtn) {
        deleteBtn.addEventListener('click', async () => {
          const confirmed = await modernConfirm(
            'Are you sure you want to delete this request? This action cannot be undone.',
            'Delete Request',
            'danger'
          );

          if (confirmed) {
            try {
              const response = await fetch(`/api/requests/${request.id}`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
              });

              const result = await response.json();
              if (result.success) {
                showToast('Request deleted successfully', 'success');

                // Close modal and refresh calendar
                const modal = bootstrap.Modal.getInstance(
                  document.getElementById('requestDetailModal')
                );
                modal.hide();
                await loadExistingRequests();
              } else {
                showToast(result.error || 'Failed to delete request', 'error');
              }
            } catch (error) {
              console.error('Error deleting request:', error);
              showToast('Failed to delete request', 'error');
            }
          }
        });
      }
    }
  }

  // Initialize calendar
  const calendar = new CalendarManager();
  window.updateDateType = function (index, newType) {
    // Update the selectedDates array
    selectedDates[index].type = newType;

    // Show/hide flight number input based on selection
    const flightInput = document.querySelector(`input[data-index="${index}"]`);
    if (flightInput) {
      if (newType === 'FLIGHT') {
        flightInput.style.display = 'block';
        flightInput.required = true;
        flightInput.focus();
      } else {
        flightInput.style.display = 'none';
        flightInput.required = false;
        flightInput.value = '';
        selectedDates[index].flightNumber = '';
      }
    }

    // âœ… UPDATE PREVIEW IMMEDIATELY
    updateRequestPreview();
  };

  window.updateFlightNumber = function (index, flightNumber) {
    // Update the selectedDates array
    selectedDates[index].flightNumber = flightNumber;

    // âœ… UPDATE PREVIEW IMMEDIATELY
    updateRequestPreview();
  };
  window.updateRequestPreview = function () {
    const requestLinesContainer = document.getElementById('requestLines');
    const emailSubjectElement = document.getElementById('emailSubject');
    const customMessagePreview = document.getElementById(
      'customMessagePreview'
    );
    const userSignatureElement = document.getElementById('userSignature');

    if (!requestLinesContainer || !emailSubjectElement) return;

    // âœ… FIX: Generate proper request lines from selected dates
    if (selectedDates && selectedDates.length > 0) {
      const requestLines = selectedDates
        .map((dateInfo) => {
          const formattedDate = formatDateForEmail(new Date(dateInfo.date));

          switch (dateInfo.type) {
            case 'REQ_DO':
              return `REQ DO - ${formattedDate}`;
            case 'PM_OFF':
              return `REQ PM OFF - ${formattedDate}`;
            case 'AM_OFF':
              return `REQ AM OFF - ${formattedDate}`;
            case 'FLIGHT':
              return `REQ FLIGHT ${dateInfo.flightNumber || '[NUMBER]'} - ${formattedDate}`; // âœ… FIXED: REQ FLIGHT
            default:
              return `${dateInfo.type} - ${formattedDate}`;
          }
        })
        .join('<br>');

      requestLinesContainer.innerHTML = requestLines;
    } else {
      requestLinesContainer.innerHTML =
        '<em class="text-muted">Please fill in the required fields</em>';
    }

    // âœ… FIX: Generate proper subject with correct format
    if (selectedDates && selectedDates.length > 0) {
      const firstDate = new Date(selectedDates[0].date);
      const monthNames = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
      ];
      const monthName = monthNames[firstDate.getMonth()];
      const year = firstDate.getFullYear();
      const userCode =
        window.currentUserData?.code ||
        window.TUIFLY_CONFIG?.EMPLOYEE_CODE ||
        'XXX';

      emailSubjectElement.textContent = `${userCode} - CREW REQUEST - ${monthName} ${year}`;
    }

    // âœ… FIX: Update custom message preview
    const customMessage = document.getElementById('customMessage');
    const customMessageSpacer = document.getElementById('customMessageSpacer');

    if (customMessage && customMessagePreview) {
      if (customMessage.value.trim()) {
        customMessagePreview.textContent = customMessage.value;
        customMessagePreview.style.display = 'block';

        // âœ… Show spacer to create line break after custom message
        if (customMessageSpacer) {
          customMessageSpacer.style.display = 'block';
        }
      } else {
        customMessagePreview.style.display = 'none';

        // Hide spacer when no custom message
        if (customMessageSpacer) {
          customMessageSpacer.style.display = 'none';
        }
      }
    }

    // âœ… FIX: Update signature properly
    if (userSignatureElement) {
      const signature =
        window.currentUserData?.signature ||
        window.TUIFLY_CONFIG?.EMPLOYEE_SIGNATURE ||
        `Brgds,\n${window.currentUserData?.name || window.TUIFLY_CONFIG?.EMPLOYEE_NAME || 'Unknown'}`;

      userSignatureElement.innerHTML = `<br><br>${signature.replace(/\n/g, '<br>')}`;
    }
  };

  // âœ… ADD: Helper function to format dates properly
  function formatDateForEmail(date) {
    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
  }

  // âœ… CENTRALIZED EMAIL GENERATION (matches gmailService.js)
  function generateEmailContentLikeGmailService(user, requests) {
    const firstRequest = requests[0];
    const startDate = new Date(firstRequest.startDate);

    // Generate subject (matches gmailService)
    const monthNames = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December',
    ];
    const monthName = monthNames[startDate.getMonth()];
    const year = startDate.getFullYear();
    const subject = `${user.code} - CREW REQUEST - ${monthName} ${year}`;

    // Generate request lines (matches gmailService format)
    const requestLines = requests
      .map((request) => {
        const start = new Date(request.startDate);
        const end = new Date(request.endDate);
        const dates = [];

        // Generate all dates in range
        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
          dates.push(new Date(d));
        }

        return dates
          .map((date) => {
            const formattedDate = `${date.getDate().toString().padStart(2, '0')}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getFullYear()}`;

            switch (request.type) {
              case 'REQ_DO':
                return `REQ DO - ${formattedDate}`;
              case 'PM_OFF':
                return `REQ PM OFF - ${formattedDate}`;
              case 'AM_OFF':
                return `REQ AM OFF - ${formattedDate}`;
              case 'FLIGHT':
                return `FLIGHT ${request.flightNumber || ''} - ${formattedDate}`;
              default:
                return `${request.type} - ${formattedDate}`;
            }
          })
          .join('\n');
      })
      .join('\n');

    return {
      subject: subject,
      requestLines: requestLines,
      body: `Dear,\n\n${requestLines}${firstRequest.customMessage ? '\n\n' + firstRequest.customMessage : ''}\n\n${user.signature}`,
    };
  }

  // âœ… ADD DYNAMIC UPDATE EVENT LISTENERS
  document.addEventListener('DOMContentLoaded', function () {
    const fieldsToWatch = [
      'startDate',
      'endDate',
      'type',
      'flightNumber',
      'customMessage',
    ];
    fieldsToWatch.forEach((fieldId) => {
      const field = document.getElementById(fieldId);
      if (field) {
        field.addEventListener('change', updateRequestPreview);
        field.addEventListener('input', updateRequestPreview);
      }
    });
  });
  window.loadGroupEmailContent = async function (requestId) {
    try {
      const response = await fetch(
        `/api/requests/${requestId}/group-email-content`
      );
      const result = await response.json();

      if (result.success) {
        const emailContent = result.data.emailContent;

        // Populate the form fields
        document.getElementById('emailSubject').value = emailContent.subject;
        document.getElementById('emailBody').value = emailContent.body;

        // Show the content
        document.getElementById('emailContentDisplay').style.display = 'block';

        showToast(
          result.data.isGroup
            ? 'Group email content generated'
            : 'Email content generated',
          'success'
        );
      } else {
        showToast(result.error || 'Failed to generate email content', 'error');
      }
    } catch (error) {
      console.error('Error loading email content:', error);
      showToast('Failed to generate email content', 'error');
    }
  };
  // DST-safe date utility
  function addDays(dateStr, days) {
    const parts = dateStr.split('-');
    const date = new Date(
      parseInt(parts[0]),
      parseInt(parts[1]) - 1,
      parseInt(parts[2])
    );
    date.setDate(date.getDate() + days);
    const utcDate = new Date(
      Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())
    );
    return utcDate.toISOString().split('T')[0];
  }

  // Enhanced consecutive date validation
  function validateConsecutiveDates(dates) {
    if (dates.length <= 1) return true;

    const sortedDates = [...dates].sort();
    for (let i = 1; i < sortedDates.length; i++) {
      const expectedDate = addDays(sortedDates[i - 1], 1);
      if (sortedDates[i] !== expectedDate) {
        return false;
      }
    }
    return true;
  }

  // API Functions
  async function loadExistingRequests() {
    try {
      const response = await fetch('/api/requests');
      const data = await response.json();

      if (data.success) {
        existingRequests = data.data;
        updateStatistics(data.data);
        calendar.generateCalendar();
        initializeTooltips();
      }
    } catch (error) {
      console.error('Error loading requests:', error);
      showToast('Failed to load existing requests', 'error');
    }
  }

  function updateStatistics(requests) {
    const pending = requests.filter((r) => r.status === 'PENDING').length;
    const approved = requests.filter((r) => r.status === 'APPROVED').length;
    const denied = requests.filter((r) => r.status === 'DENIED').length;

    document.getElementById('pendingCount').textContent = pending;
    document.getElementById('approvedCount').textContent = approved;
    document.getElementById('deniedCount').textContent = denied;
    document.getElementById('totalCount').textContent = requests.length;
  }

  function initializeTooltips() {
    const tooltipTriggerList = [].slice.call(
      document.querySelectorAll('[data-bs-toggle="tooltip"]')
    );
    tooltipTriggerList.map(
      (tooltipTriggerEl) => new bootstrap.Tooltip(tooltipTriggerEl)
    );
  }

  // Modal Functions
  function openGroupRequestModal() {
    if (selectedDates.length === 0) {
      showToast('Please select dates first', 'warning');
      return;
    }

    // Create modal if it doesn't exist
    let modal = document.getElementById('groupRequestModal');
    if (!modal) {
      createGroupRequestModal();
      modal = document.getElementById('groupRequestModal');
    }

    // Populate dates in modal
    populateModalDates();

    // Show modal
    const bootstrapModal = new bootstrap.Modal(modal);
    bootstrapModal.show();

    // âœ… Initialize email preview and add dynamic listeners after modal is visible
    setTimeout(() => {
      updateRequestPreview(); // Initial preview
      addDynamicPreviewListeners(); // Add change listeners
    }, 200); // Increased timeout to ensure elements are ready
  }

  function addDynamicPreviewListeners() {
    // Find all the date type dropdowns and flight number inputs
    const dateInputs = document.querySelectorAll(
      'select[id^="dateType_"], input[id^="flightNumber_"]'
    );

    dateInputs.forEach((input) => {
      input.addEventListener('change', function () {
        // Update the selectedDates array with the new values
        updateSelectedDatesFromInputs();
        // Trigger preview update
        updateRequestPreview();
      });
    });

    // Also listen to custom message changes
    const customMessageInput = document.getElementById('customMessage');
    if (customMessageInput) {
      customMessageInput.addEventListener('input', function () {
        updateRequestPreview();
      });
    }
  }

  // âœ… ADD: Function to update selectedDates array from current input values
  function updateSelectedDatesFromInputs() {
    selectedDates.forEach((dateInfo, index) => {
      const typeSelect = document.getElementById(`dateType_${index}`);
      const flightInput = document.getElementById(`flightNumber_${index}`);

      if (typeSelect) {
        dateInfo.type = typeSelect.value;
      }

      if (flightInput && dateInfo.type === 'FLIGHT') {
        dateInfo.flightNumber = flightInput.value;
      }
    });
  }

  function createGroupRequestModal() {
    const modalHTML = `
        <div class="modal fade" id="groupRequestModal" tabindex="-1">
          <div class="modal-dialog modal-lg">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title">
                  <i class="bi bi-calendar-plus"></i> Create Time-Off Request
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
              </div>
              <div class="modal-body">
                <form id="groupRequestForm">
                  <div class="mb-3">
                    <label class="form-label">Selected Dates</label>
                    <div id="selectedDatesList" class="border rounded p-3 bg-light">
                      <!-- Dates will be populated here -->
                    </div>
                  </div>

                  <div class="mb-3">
                    <label for="customMessage" class="form-label">Custom Message (Optional)</label>
                    <textarea
                      class="form-control"
                      id="customMessage"
                      rows="3"
                      placeholder="Additional information or reason for time-off...">
                    </textarea>
                  </div>

                  <div class="alert alert-info">
                    <i class="bi bi-info-circle me-2"></i>
                    <small>
                      Request will be sent to scheduling@tuifly.be for approval.
                    </small>
                  </div>
                </form>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="submitGroupRequest">
                  <i class="bi bi-send me-1"></i>Submit Request
                </button>
              </div>
            </div>
          </div>
        </div>
      `;
    document.body.insertAdjacentHTML('beforeend', modalHTML);
  }

  function populateModalDates() {
    const container = document.getElementById('selectedDatesList');
    container.innerHTML = '';

    selectedDates.forEach((dateObj, index) => {
      const date = new Date(dateObj.date);
      const dateStr = date.toLocaleDateString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      });

      const dateRow = document.createElement('div');
      dateRow.className = 'row mb-2 align-items-center';
      const isFlightType = dateObj.type === 'FLIGHT';

      dateRow.innerHTML = `
  <div class="col-md-6">
    <span class="fw-bold">${dateStr}</span>
  </div>
  <div class="col-md-4">
    <select class="form-select form-select-sm" onchange="updateDateType(${index}, this.value)">
      <option value="REQ_DO" ${dateObj.type === 'REQ_DO' ? 'selected' : ''}>Full Day Off</option>
      <option value="PM_OFF" ${dateObj.type === 'PM_OFF' ? 'selected' : ''}>PM Off</option>
      <option value="AM_OFF" ${dateObj.type === 'AM_OFF' ? 'selected' : ''}>AM Off</option>
      <option value="FLIGHT" ${dateObj.type === 'FLIGHT' ? 'selected' : ''}>Flight</option>
    </select>
  </div>
  <div class="col-md-2">
    <input 
      type="text" 
      class="form-control form-control-sm" 
      placeholder="Flight#"
      data-index="${index}"
      value="${dateObj.flightNumber || ''}"
      onchange="updateFlightNumber(${index}, this.value)"
      oninput="updateFlightNumber(${index}, this.value)"
      style="display: ${isFlightType ? 'block' : 'none'}"
      ${isFlightType ? 'required' : ''}
    />
  </div>
`;

      container.appendChild(dateRow);
    });
  }

  function updateDateType(index, type) {
    selectedDates[index].type = type;

    const flightInput = document.getElementById(`flight-${index}`);
    if (type === 'FLIGHT') {
      flightInput.style.display = 'block';
      flightInput.disabled = false;
      flightInput.required = true;
      flightInput.focus();
    } else {
      flightInput.style.display = 'none';
      flightInput.disabled = true;
      flightInput.required = false;
      selectedDates[index].flightNumber = '';
    }
  }

  function updateFlightNumber(index, flightNumber) {
    selectedDates[index].flightNumber = flightNumber;
  }

  async function submitGroupRequest() {
    if (isSubmitting) return;

    const customMessage = document.getElementById('customMessage').value.trim();
    const submitButton = document.getElementById('submitGroupRequest');

    // Validate flight numbers
    const flightDates = selectedDates.filter((d) => d.type === 'FLIGHT');
    for (const date of flightDates) {
      if (!date.flightNumber || !date.flightNumber.startsWith('TB')) {
        showToast('Flight numbers must start with "TB"', 'error');
        return;
      }
    }

    if (!validateConsecutiveDates(selectedDates.map((d) => d.date))) {
      showToast('Selected dates must be consecutive', 'error');
      return;
    }

    if (selectedDates.length === 0) return;

    isSubmitting = true;
    submitButton.disabled = true;
    submitButton.innerHTML =
      '<i class="bi bi-hourglass-split me-1"></i>Submitting...';

    try {
      const response = await fetch('/api/requests/group', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          dates: selectedDates,
          customMessage: customMessage || null,
        }),
      });

      const result = await response.json();

      if (result.success) {
        const modal = bootstrap.Modal.getInstance(
          document.getElementById('groupRequestModal')
        );
        modal.hide();

        selectedDates = [];
        calendar.updateDateSelection();
        calendar.updateFloatingButton();

        await loadExistingRequests();
        showToast(result.message, 'success');
      } else {
        showToast(result.error, 'error');
      }
    } catch (error) {
      console.error('Error creating group request:', error);
      showToast('Failed to create request', 'error');
    } finally {
      isSubmitting = false;
      submitButton.disabled = false;
      submitButton.innerHTML = '<i class="bi bi-send me-1"></i>Submit Request';
    }
  }

  // Event Listeners
  document.addEventListener('DOMContentLoaded', async () => {
    await loadUserDataAndSettings();
    await loadExistingRequests();
    try {
      const response = await fetch('/settings/email-preference');
      const data = await response.json();
      if (data.success && typeof loadEmailPreferences === 'function') {
        loadEmailPreferences(data.data);
      }
    } catch (error) {
      console.log('Could not load email preferences for header badge');
    }
    const createBtn = document.getElementById('createRequestBtn');
    if (createBtn && !createBtn.hasAttribute('data-listener-added')) {
      createBtn.addEventListener('click', openGroupRequestModal);
      createBtn.setAttribute('data-listener-added', 'true');
    }

    const prevBtn = document.getElementById('prevMonthBtn');
    const nextBtn = document.getElementById('nextMonthBtn');

    if (prevBtn && !prevBtn.hasAttribute('data-listener-added')) {
      prevBtn.addEventListener('click', () => calendar.navigatePrevious());
      prevBtn.setAttribute('data-listener-added', 'true');
    }

    if (nextBtn && !nextBtn.hasAttribute('data-listener-added')) {
      nextBtn.addEventListener('click', () => calendar.navigateNext());
      nextBtn.setAttribute('data-listener-added', 'true');
    }

    document.addEventListener('click', (e) => {
      if (e.target.id === 'submitGroupRequest') {
        e.preventDefault();
        submitGroupRequest();
      }
    });

    document.addEventListener('hidden.bs.modal', (e) => {
      if (e.target.id === 'groupRequestModal') {
        document.getElementById('groupRequestForm')?.reset();
        const customMessage = document.getElementById('customMessage');
        if (customMessage) customMessage.value = '';
        isSubmitting = false;
      }
    });
  });

  // Toast notification function
  function showToast(message, type = 'info') {
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.className =
        'toast-container position-fixed top-0 end-0 p-3';
      toastContainer.style.zIndex = '1055';
      document.body.appendChild(toastContainer);
    }

    const toastId = 'toast_' + Date.now();
    const bgClass =
      type === 'success'
        ? 'bg-success'
        : type === 'error'
          ? 'bg-danger'
          : type === 'warning'
            ? 'bg-warning'
            : 'bg-info';

    const toastHTML = `
          <div id="${toastId}" class="toast ${bgClass} text-white" role="alert">
            <div class="d-flex">
              <div class="toast-body">${message}</div>
              <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
          </div>
        `;

    toastContainer.insertAdjacentHTML('beforeend', toastHTML);

    const toastElement = document.getElementById(toastId);
    const toast = new bootstrap.Toast(toastElement, {
      autohide: true,
      delay: type === 'error' ? 5000 : 3000,
    });
    toast.show();

    toastElement.addEventListener('hidden.bs.toast', () => {
      toastElement.remove();
    });
  }
  function getEmailStatusTooltip(request) {
    const status = getEmailStatusIcon(request);
    const tooltipMap = {
      'âœ…':
        request.emailMode === 'automatic'
          ? 'Email sent successfully'
          : 'Email confirmed sent',
      'âŒ': 'Email failed to send',
      'ðŸ”„': 'Email sending in progress',
      'ðŸ“§': 'Email ready to copy',
      'âš ï¸': 'Email not sent yet',
      'â“': 'Unknown email status',
    };
    return tooltipMap[status] || 'Unknown email status';
  }

  // âž• REQUEST DETAIL MODAL FUNCTION
  function showRequestDetailModal(request) {
    // Create modal HTML
    const modalHTML = `
        <div class="modal fade" id="requestDetailModal" tabindex="-1">
          <div class="modal-dialog modal-lg">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title">
                  <i class="bi bi-calendar-event text-primary"></i>
                  Request Details
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
              </div>
              <div class="modal-body">
                ${generateRequestDetailContent(request)}
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                ${generateModalActionButtons(request)}
              </div>
            </div>
          </div>
        </div>
      `;

    // Remove existing modal if present
    const existingModal = document.getElementById('requestDetailModal');
    if (existingModal) {
      existingModal.remove();
    }

    // Add modal to page
    document.body.insertAdjacentHTML('beforeend', modalHTML);

    // Show modal
    const modal = new bootstrap.Modal(
      document.getElementById('requestDetailModal'),
      {
        backdrop: 'static',
        keyboard: true,
        focus: true,
      }
    );
    const modalElement = document.getElementById('requestDetailModal');

    modalElement.addEventListener('shown.bs.modal', function () {
      this.removeAttribute('aria-hidden');
      // Focus the first focusable element
      const firstFocusable = this.querySelector(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      if (firstFocusable) firstFocusable.focus();
    });

    modalElement.addEventListener('hidden.bs.modal', function () {
      this.setAttribute('aria-hidden', 'true');
      this.remove();
    });

    modal.show();
  }

  function generateRequestDetailContent(request) {
    const emailStatusIcon = getEmailStatusIcon(request);
    const emailStatusTooltip = getEmailStatusTooltip(request);

    return `
        <div class="row">
          <div class="col-md-6">
            <h6><i class="bi bi-info-circle text-info"></i> Request Information</h6>
            <table class="table table-sm">
              <tr>
                <td><strong>Type:</strong></td>
                <td><span class="badge bg-primary">${request.type}</span></td>
              </tr>
              <tr>
                <td><strong>Start Date:</strong></td>
                <td>${formatDisplayDate(request.startDate)}</td>
              </tr>
              <tr>
                <td><strong>End Date:</strong></td>
                <td>${formatDisplayDate(request.endDate)}</td>
              </tr>
              <tr>
                <td><strong>Status:</strong></td>
                <td><span class="badge bg-${getStatusColor(request.status)}">${request.status}</span></td>
              </tr>
              ${
                request.flightNumber
                  ? `
              <tr>
                <td><strong>Flight Number:</strong></td>
                <td>${request.flightNumber}</td>
              </tr>
              `
                  : ''
              }
              ${
                request.customMessage
                  ? `
              <tr>
                <td><strong>Message:</strong></td>
                <td>${request.customMessage}</td>
              </tr>
              `
                  : ''
              }
            </table>
          </div>

          <div class="col-md-6">
            <h6><i class="bi bi-envelope text-warning"></i> Email Status</h6>
            <div class="card bg-light">
              <div class="card-body">
                <div class="d-flex align-items-center mb-2">
                  <span class="fs-4 me-2">${emailStatusIcon}</span>
                  <div>
                    <strong>${emailStatusTooltip}</strong><br>
                    <small class="text-muted">Mode: ${request.emailMode || 'Unknown'}</small>
                  </div>
                </div>

                ${generateEmailActionSection(request)}
              </div>
            </div>
          </div>
        </div>
      `;
  }

  function generateEmailActionSection(request) {
    const requestEmailMode = request.emailMode || 'manual';
    const userCurrentMode = window.currentEmailPreference || 'manual';

    if (requestEmailMode === 'manual') {
      // This request was created in manual mode
      if (request.manualEmailContent && !request.manualEmailConfirmed) {
        return `
          <div class="mt-3">
            <div class="alert alert-info">
              <small><strong>Manual Email Mode:</strong> This request was created in manual mode.</small>
            </div>
            <h6>ðŸ“§ Email Content Ready to Copy</h6>
            <div class="email-copy-section">
              <!-- Email copy interface -->
              <button class="btn btn-success btn-sm" onclick="markEmailAsSent(${request.id})">
                âœ… Mark as Sent
              </button>
            </div>
          </div>
        `;
      } else if (request.manualEmailConfirmed) {
        return `
          <div class="mt-3">
            <div class="alert alert-success">
              <small><strong>Manual Email:</strong> You confirmed this email was sent manually.</small>
            </div>
          </div>
        `;
      }
    } else if (requestEmailMode === 'automatic') {
      // This request was created in automatic mode
      if (request.emailSent) {
        return `
          <div class="mt-3">
            <div class="alert alert-success">
              <small><strong>Automatic Email:</strong> Email was sent automatically on ${new Date(request.emailSent).toLocaleString()}.</small>
            </div>
          </div>
        `;
      } else if (request.emailFailed) {
        return `
          <div class="mt-3">
            <div class="alert alert-danger">
              <small><strong>Automatic Email Failed:</strong> ${request.emailFailedReason || 'Unknown error'}</small>
            </div>
            ${
              userCurrentMode === 'automatic'
                ? `<button class="btn btn-primary btn-sm" onclick="retryEmailSend(${request.id})">
                ðŸ”„ Retry Send
              </button>`
                : `<small class="text-muted">Switch to automatic mode in settings to retry sending.</small>`
            }
          </div>
        `;
      }
    }

    return '';
  }

  function generateModalActionButtons(request) {
    let buttons = '';

    if (request.status === 'PENDING') {
      buttons += `
          <button type="button" class="btn btn-success" onclick="updateRequestStatus(${request.id}, 'APPROVED')">
            <i class="bi bi-check-circle"></i> Mark Approved
          </button>
          <button type="button" class="btn btn-danger" onclick="updateRequestStatus(${request.id}, 'DENIED')">
            <i class="bi bi-x-circle"></i> Mark Denied
          </button>
        `;
    }

    return buttons;
  }

  // âž• MODAL ACTION FUNCTIONS
  function attachModalEventListeners(request) {
    // These functions will be available globally for the modal
    window.copyToClipboard = function (elementId) {
      const element = document.getElementById(elementId);
      if (!element) {
        showToast('Element not found', 'error');
        return;
      }

      let textToCopy = '';

      // Get text based on element type
      if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
        textToCopy = element.value;
      } else {
        textToCopy = element.textContent || element.innerText;
      }

      if (!textToCopy.trim()) {
        showToast('Nothing to copy', 'error');
        return;
      }

      // Use modern clipboard API with fallback
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard
          .writeText(textToCopy)
          .then(() => {
            showToast('Copied to clipboard!', 'success');
          })
          .catch(() => {
            fallbackCopy(textToCopy);
          });
      } else {
        fallbackCopy(textToCopy);
      }
    };

    function fallbackCopy(text) {
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-9999px';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();

      try {
        document.execCommand('copy');
        showToast('Copied to clipboard!', 'success');
      } catch (err) {
        console.error('Copy failed:', err);
        showToast('Failed to copy', 'error');
      }

      document.body.removeChild(textArea);
    }
    // FIXED: Delete function to handle group requests
    // Add this to calendar.ejs

    // âœ… Global delete function for both single and group requests
    window.deleteRequest = async function (requestId, isGroup = false) {
      const message = isGroup
        ? 'Are you sure you want to delete this entire group request? This will delete all dates in the group. This action cannot be undone.'
        : 'Are you sure you want to delete this request? This action cannot be undone.';

      const title = isGroup ? 'Delete Group Request' : 'Delete Request';

      const confirmed = await showConfirmDialog(message, title, 'danger');

      if (confirmed) {
        try {
          // âœ… Use new API endpoint for group deletion
          const url = isGroup
            ? `/api/requests/${requestId}/delete-group`
            : `/api/requests/${requestId}`;

          const response = await fetch(url, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
          });

          const result = await response.json();
          if (result.success) {
            const deleteMessage = isGroup
              ? `Group request deleted successfully (${result.data?.deletedCount || 'multiple'} requests)`
              : 'Request deleted successfully';

            showToast(deleteMessage, 'success');

            // Close modal and refresh calendar
            const modal = bootstrap.Modal.getInstance(
              document.getElementById('requestDetailModal')
            );
            modal.hide();
            await loadExistingRequests();
          } else {
            showToast(result.error || 'Failed to delete request', 'error');
          }
        } catch (error) {
          console.error('Error deleting request:', error);
          showToast('Failed to delete request', 'error');
        }
      }
    };
    window.markEmailAsSent = async function (requestId) {
      try {
        const response = await fetch(
          `/api/requests/${requestId}/mark-email-sent`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
          }
        );

        const result = await response.json();
        if (result.success) {
          const message = result.data?.groupId
            ? `Email marked as sent for group of ${result.data.updatedRequests} requests`
            : 'Email marked as sent successfully';

          showToast(message, 'success');

          // Close modal and refresh calendar
          const modal = bootstrap.Modal.getInstance(
            document.getElementById('requestDetailModal')
          );
          modal.hide();
          await loadExistingRequests();
        } else {
          showToast(result.error || 'Failed to mark email as sent', 'error');
        }
      } catch (error) {
        console.error('Error marking email as sent:', error);
        showToast('Failed to mark email as sent', 'error');
      }
    };
    window.copyToClipboard = async function (elementId) {
      try {
        const element = document.getElementById(elementId);
        if (!element) {
          showToast('Element not found', 'error');
          return;
        }

        // Use modern clipboard API if available
        if (navigator.clipboard) {
          await navigator.clipboard.writeText(element.value);
        } else {
          // Fallback for older browsers
          element.select();
          document.execCommand('copy');
        }

        showToast('Copied to clipboard!', 'success');
      } catch (error) {
        console.error('Failed to copy to clipboard:', error);
        showToast('Failed to copy to clipboard', 'error');
      }
    };
    window.resendEmail = async function (requestId) {
      try {
        const response = await fetch(
          `/api/requests/${requestId}/resend-email`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
          }
        );

        const result = await response.json();
        if (result.success) {
          showToast('Email resent successfully', 'success');

          // Close modal and refresh calendar
          const modal = bootstrap.Modal.getInstance(
            document.getElementById('requestDetailModal')
          );
          modal.hide();
          await loadExistingRequests();
        } else {
          showToast(result.error || 'Failed to resend email', 'error');
        }
      } catch (error) {
        console.error('Error resending email:', error);
        showToast('Failed to resend email', 'error');
      }
    };

    window.updateRequestStatus = async function (requestId, status) {
      try {
        const response = await fetch(`/api/requests/${requestId}/status`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ status }),
        });

        const data = await response.json();

        if (data.success) {
          showToast(`Request ${status.toLowerCase()} successfully!`, 'success');
          bootstrap.Modal.getInstance(
            document.getElementById('requestDetailModal')
          ).hide();
          loadRequests(); // Refresh calendar
        } else {
          throw new Error(data.message);
        }
      } catch (error) {
        console.error('Error updating request status:', error);
        showToast('Failed to update request status', 'error');
      }
    };

    window.retryEmailSend = async function (requestId) {
      try {
        const response = await fetch(`/api/requests/${requestId}/retry-email`, {
          method: 'POST',
        });

        const data = await response.json();

        if (data.success) {
          showToast('Email sent successfully!', 'success');
          bootstrap.Modal.getInstance(
            document.getElementById('requestDetailModal')
          ).hide();
          loadRequests(); // Refresh calendar
        } else {
          throw new Error(data.message);
        }
      } catch (error) {
        console.error('Error retrying email send:', error);
        showToast('Failed to resend email: ' + error.message, 'error');
      }
    };
  }

  // âž• UTILITY FUNCTIONS
  function formatDisplayDate(dateString) {
    return new Date(dateString).toLocaleDateString('en-GB');
  }

  function getStatusColor(status) {
    const colors = {
      PENDING: 'warning',
      APPROVED: 'success',
      DENIED: 'danger',
    };
    return colors[status] || 'secondary';
  }

  // ðŸ” FIND where request elements get click handlers and ADD this to show the detail modal:
  // Look for: requestElement.addEventListener('click', ...) or similar and MODIFY to:
  // (This should be added to the existing request element creation)

  // Add click handler to show request details (modify existing click handler)
  requestElement.addEventListener('click', (e) => {
    e.stopPropagation();
    showRequestDetailModal(existingRequest);
  });
</script>
