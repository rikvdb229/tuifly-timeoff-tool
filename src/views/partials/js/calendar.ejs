<script>
  // Configuration from meta tags
  const CONFIG = {
    MIN_ADVANCE_DAYS: parseInt(
      document.querySelector('meta[name="min-advance-days"]')?.content || 60
    ),
    MAX_ADVANCE_DAYS: parseInt(
      document.querySelector('meta[name="max-advance-days"]')?.content || 120
    ),
    MAX_DAYS_PER_REQUEST: parseInt(
      document.querySelector('meta[name="max-days-per-request"]')?.content || 4
    ),
    REQUEST_TYPES: {
      REQ_DO: 'DO',
      PM_OFF: 'PM',
      AM_OFF: 'AM',
      FLIGHT: 'FL',
    },
  };

  // Global state
  let existingRequests = [];
  let selectedDates = [];
  let isSubmitting = false;
  let currentUserData = null;
  async function loadUserDataAndSettings() {
    try {
      const response = await fetch('/settings/api');
      const data = await response.json();
      if (data.success) {
        // Load user data
        currentUserData = data.data.user;
        window.currentUserData = currentUserData; // Make it globally available

        // Load email preference
        userEmailPreference = data.data.user.emailPreference || 'automatic';

        console.log('User data loaded:', currentUserData);
        console.log('User email preference:', userEmailPreference);
      }
    } catch (error) {
      console.error('Failed to load user data and settings:', error);
      // Default to automatic if we can't load settings
      userEmailPreference = 'automatic';
    }
  }
  // ===== FRONTEND: Add to calendar.ejs global functions =====

  window.updateRequestStatus = async function (
    requestId,
    newStatus,
    updateGroup = false
  ) {
    console.log(
      'updateRequestStatus called:',
      requestId,
      newStatus,
      updateGroup
    );

    const statusText = newStatus === 'APPROVED' ? 'approve' : 'deny';
    const groupText = updateGroup ? ' entire group' : '';
    const message = `Are you sure you want to ${statusText} this${groupText} request? This action can be changed later if needed.`;

    // Use correct dialog type for deny
    const dialogType = newStatus === 'APPROVED' ? 'success' : 'denied';

    const confirmed = await showConfirmDialog(
      message,
      `${newStatus === 'APPROVED' ? 'Approve' : 'Deny'} Request${updateGroup ? ' Group' : ''}`,
      dialogType
    );

    if (confirmed) {
      try {
        const response = await fetch(`/api/requests/${requestId}/status`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            status: newStatus,
            method: 'manual_user_update',
            updateGroup: updateGroup, // Use the updateGroup parameter
          }),
        });

        const result = await response.json();
        if (result.success) {
          const successMessage = updateGroup
            ? `${result.data.updatedCount} requests marked as ${newStatus.toLowerCase()}!`
            : `Request marked as ${newStatus.toLowerCase()}!`;

          showToast(successMessage, 'success');

          // Close modal and refresh calendar
          const modal = bootstrap.Modal.getInstance(
            document.getElementById('requestDetailModal')
          );
          modal.hide();
          await loadExistingRequests();
        } else {
          showToast(result.error || `Failed to ${statusText} request`, 'error');
        }
      } catch (error) {
        console.error(`Error ${statusText}ing request:`, error);
        showToast(`Failed to ${statusText} request`, 'error');
      }
    }
  };
  window.updateIndividualStatus = async function (requestId, newStatus) {
    console.log('updateIndividualStatus called:', requestId, newStatus);

    try {
      const response = await fetch(`/api/requests/${requestId}/status`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          status: newStatus,
          method: 'manual_individual_update',
          updateGroup: false, // Only update this specific request
        }),
      });

      const result = await response.json();
      if (result.success) {
        // Update the button states for this specific request
        const allButtons = document.querySelectorAll(
          `[id^="${['deny', 'pending', 'approve'].join(`-btn-${requestId}"], [id^="`)}-btn-${requestId}"]`
        );
        allButtons.forEach((btn) => btn.classList.remove('active'));

        // Activate the correct button
        const buttonMap = {
          DENIED: `deny-btn-${requestId}`,
          PENDING: `pending-btn-${requestId}`,
          APPROVED: `approve-btn-${requestId}`,
        };

        const activeButton = document.getElementById(buttonMap[newStatus]);
        if (activeButton) {
          activeButton.classList.add('active');
        }

        // Update the status badge
        const statusBadge = document.getElementById(
          `status-badge-${requestId}`
        );
        if (statusBadge) {
          statusBadge.textContent = newStatus;
          statusBadge.className = `badge bg-${getStatusColor(newStatus)} me-3`;
        }

        showToast(`Date marked as ${newStatus.toLowerCase()}`, 'success');

        // Refresh calendar to show updated status
        setTimeout(() => loadExistingRequests(), 1000);
      } else {
        showToast(result.error || 'Failed to update status', 'error');
      }
    } catch (error) {
      console.error('Error updating individual status:', error);
      showToast('Failed to update status', 'error');
    }
  };

  // ===== BULK STATUS UPDATE =====
  window.bulkUpdateStatus = async function (newStatus) {
    console.log('bulkUpdateStatus called:', newStatus);

    const statusText = newStatus.toLowerCase();
    const confirmMessage = `Are you sure you want to mark ALL dates as ${statusText}?`;

    // Use appropriate dialog type
    let dialogType = 'warning';
    if (newStatus === 'APPROVED') dialogType = 'success';
    if (newStatus === 'DENIED') dialogType = 'denied';

    const confirmed = await showConfirmDialog(
      confirmMessage,
      `${newStatus === 'APPROVED' ? 'Approve' : newStatus === 'DENIED' ? 'Deny' : 'Reset'} All Dates`,
      dialogType
    );

    if (confirmed) {
      try {
        // Get all request IDs from the current modal
        const statusBadges = document.querySelectorAll('[id^="status-badge-"]');
        const requestIds = [];

        statusBadges.forEach((badge) => {
          const idMatch = badge.id.match(/status-badge-(\d+)/);
          if (idMatch) {
            requestIds.push(parseInt(idMatch[1]));
          }
        });

        if (requestIds.length === 0) {
          showToast('No requests found to update', 'error');
          return;
        }

        console.log('Updating request IDs:', requestIds);

        // Update all requests
        const updatePromises = requestIds.map((id) =>
          fetch(`/api/requests/${id}/status`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              status: newStatus,
              method: 'manual_bulk_update',
              updateGroup: false, // Update individually to ensure all get updated
            }),
          })
        );

        const responses = await Promise.all(updatePromises);
        const results = await Promise.all(responses.map((r) => r.json()));

        // Check if all updates were successful
        const failedUpdates = results.filter((r) => !r.success);
        if (failedUpdates.length > 0) {
          console.error('Some updates failed:', failedUpdates);
          showToast(
            `Failed to update ${failedUpdates.length} requests`,
            'error'
          );
          return;
        }

        // Update all button states in the modal
        requestIds.forEach((requestId) => {
          // Remove active class from all buttons for this request
          const allButtons = document.querySelectorAll(
            `[id^="${['deny', 'pending', 'approve'].join(`-btn-${requestId}"], [id^="`)}-btn-${requestId}"]`
          );
          allButtons.forEach((btn) => btn.classList.remove('active'));

          // Activate the correct button
          const buttonMap = {
            DENIED: `deny-btn-${requestId}`,
            PENDING: `pending-btn-${requestId}`,
            APPROVED: `approve-btn-${requestId}`,
          };

          const activeButton = document.getElementById(buttonMap[newStatus]);
          if (activeButton) {
            activeButton.classList.add('active');
          }

          // Update the status badge
          const statusBadge = document.getElementById(
            `status-badge-${requestId}`
          );
          if (statusBadge) {
            statusBadge.textContent = newStatus;
            statusBadge.className = `badge bg-${getStatusColor(newStatus)} me-3`;
          }
        });

        showToast(
          `All ${requestIds.length} dates marked as ${statusText}`,
          'success'
        );

        // Refresh calendar to show updated status
        setTimeout(() => loadExistingRequests(), 1000);
      } catch (error) {
        console.error('Error in bulk update:', error);
        showToast('Failed to update all dates', 'error');
      }
    }
  };
  window.generateSingleEmailContent = function (request) {
    const startDate = new Date(request.startDate);
    const month = startDate.toLocaleDateString('en-US', {
      month: 'long',
      year: 'numeric',
    });

    let bodyLines = ['Dear,', ''];

    let line = `${request.startDate} - `;
    switch (request.type) {
      case 'REQ_DO':
        line += 'REQ DO';
        break;
      case 'PM_OFF':
        line += 'PM OFF';
        break;
      case 'AM_OFF':
        line += 'AM OFF';
        break;
      case 'FLIGHT':
        line += 'FLIGHT';
        break;
      default:
        line += request.type;
    }

    if (request.flightNumber) {
      line += ` ${request.flightNumber}`;
    }
    bodyLines.push(line);

    if (request.customMessage) {
      bodyLines.push('');
      bodyLines.push(request.customMessage);
    }

    bodyLines.push('');
    bodyLines.push(window.currentUserData?.signature || 'Brgds,\nYour Name');

    return {
      subject: `${window.currentUserData?.code || 'RVB'} - CREW REQUEST - ${month}`,
      body: bodyLines.join('\n'),
    };
  };

  window.generateGroupEmailContent = function (request) {
    const groupRequests = window.existingRequests.filter(
      (r) => r.groupId === request.groupId
    );
    groupRequests.sort((a, b) => new Date(a.startDate) - new Date(b.startDate));

    const firstDate = new Date(groupRequests[0].startDate);
    const month = firstDate.toLocaleDateString('en-US', {
      month: 'long',
      year: 'numeric',
    });

    let bodyLines = ['Dear,', ''];

    groupRequests.forEach((req) => {
      let line = `${req.startDate} - `;
      switch (req.type) {
        case 'REQ_DO':
          line += 'REQ DO';
          break;
        case 'PM_OFF':
          line += 'PM OFF';
          break;
        case 'AM_OFF':
          line += 'AM OFF';
          break;
        case 'FLIGHT':
          line += 'FLIGHT';
          break;
        default:
          line += req.type;
      }

      if (req.flightNumber) {
        line += ` ${req.flightNumber}`;
      }
      bodyLines.push(line);
    });

    if (request.customMessage) {
      bodyLines.push('');
      bodyLines.push(request.customMessage);
    }

    bodyLines.push('');
    bodyLines.push(window.currentUserData?.signature || 'Brgds,\nYour Name');

    return {
      subject: `${window.currentUserData?.code || 'RVB'} - CREW REQUEST - ${month}`,
      body: bodyLines.join('\n'),
    };
  };
  window.markEmailAsSent = async function (requestId) {
    console.log('markEmailAsSent called with requestId:', requestId);

    try {
      const response = await fetch(
        `/api/requests/${requestId}/mark-email-sent`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        }
      );

      const result = await response.json();
      if (result.success) {
        const message = result.data?.groupId
          ? `Email marked as sent for group of ${result.data.updatedRequests} requests`
          : 'Email marked as sent successfully';

        showToast(message, 'success');

        // Close modal and refresh calendar
        const modal = bootstrap.Modal.getInstance(
          document.getElementById('requestDetailModal')
        );
        modal.hide();
        await loadExistingRequests();
      } else {
        showToast(result.error || 'Failed to mark email as sent', 'error');
      }
    } catch (error) {
      console.error('Error marking email as sent:', error);
      showToast('Failed to mark email as sent', 'error');
    }
  };

  window.deleteRequest = async function (requestId, isGroup = false) {
    console.log(
      'deleteRequest called with requestId:',
      requestId,
      'isGroup:',
      isGroup
    );

    const message = isGroup
      ? 'Are you sure you want to delete this entire group request? This will delete all dates in the group. This action cannot be undone.'
      : 'Are you sure you want to delete this request? This action cannot be undone.';

    const title = isGroup ? 'Delete Group Request' : 'Delete Request';

    const confirmed = await showConfirmDialog(message, title, 'danger');

    if (confirmed) {
      try {
        const url = isGroup
          ? `/api/requests/${requestId}/delete-group`
          : `/api/requests/${requestId}`;

        const response = await fetch(url, {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
        });

        const result = await response.json();
        if (result.success) {
          const deleteMessage = isGroup
            ? `Group request deleted successfully (${result.data?.deletedCount || 'multiple'} requests)`
            : 'Request deleted successfully';

          showToast(deleteMessage, 'success');

          // Close modal and refresh calendar
          const modal = bootstrap.Modal.getInstance(
            document.getElementById('requestDetailModal')
          );
          modal.hide();
          await loadExistingRequests();
        } else {
          showToast(result.error || 'Failed to delete request', 'error');
        }
      } catch (error) {
        console.error('Error deleting request:', error);
        showToast('Failed to delete request', 'error');
      }
    }
  };

  window.resendEmail = async function (requestId) {
    console.log('resendEmail called with requestId:', requestId);

    try {
      // ✅ Use group resend endpoint for all requests
      const response = await fetch(`/api/requests/${requestId}/resend-email`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });

      const result = await response.json();
      if (result.success) {
        const message = result.data?.isGroup
          ? `Email resent successfully for group of ${result.data.updatedCount} requests`
          : 'Email resent successfully';

        showToast(message, 'success');

        // Close modal and refresh calendar
        const modal = bootstrap.Modal.getInstance(
          document.getElementById('requestDetailModal')
        );
        modal.hide();
        await loadExistingRequests();
      } else {
        showToast(result.error || 'Failed to resend email', 'error');
      }
    } catch (error) {
      console.error('Error resending email:', error);
      showToast('Failed to resend email', 'error');
    }
  };

  // ===== COPY FUNCTION WITH EVENT DELEGATION =====
  document.addEventListener('DOMContentLoaded', function () {
    console.log('DOM loaded, setting up copy button handlers');

    // Single event listener for all copy buttons using event delegation
    document.addEventListener('click', function (event) {
      // Check if clicked element is a copy button or child of copy button
      const copyBtn = event.target.closest('[data-copy-target]');

      if (copyBtn) {
        event.preventDefault();
        event.stopPropagation();

        const targetId = copyBtn.getAttribute('data-copy-target');
        console.log('Copy button clicked, target ID:', targetId);

        if (!targetId) {
          console.error('No target ID found');
          showToast('Copy failed - no target specified', 'error');
          return;
        }

        const element = document.getElementById(targetId);
        if (!element) {
          console.error('Target element not found:', targetId);
          showToast('Copy failed - element not found', 'error');
          return;
        }

        // Get text to copy
        let textToCopy = '';
        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
          textToCopy = element.value;
        } else {
          textToCopy = element.textContent || element.innerText;
        }

        if (!textToCopy || !textToCopy.trim()) {
          console.error('No text to copy');
          showToast('Nothing to copy', 'error');
          return;
        }

        console.log('Copying text:', textToCopy.substring(0, 50) + '...');

        // Copy to clipboard
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard
            .writeText(textToCopy)
            .then(() => {
              console.log('Copy successful via clipboard API');
              showToast('Copied to clipboard!', 'success');
              highlightCopyButton(copyBtn);
            })
            .catch((err) => {
              console.error('Clipboard API failed:', err);
              fallbackCopy(textToCopy, copyBtn);
            });
        } else {
          console.log('Using fallback copy method');
          fallbackCopy(textToCopy, copyBtn);
        }
      }
    });

    function fallbackCopy(text, button) {
      try {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-9999px';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        textArea.setSelectionRange(0, 99999); // For mobile

        const successful = document.execCommand('copy');
        document.body.removeChild(textArea);

        if (successful) {
          console.log('Fallback copy successful');
          showToast('Copied to clipboard!', 'success');
          highlightCopyButton(button);
        } else {
          console.error('Fallback copy failed');
          showToast('Copy failed', 'error');
        }
      } catch (err) {
        console.error('Fallback copy error:', err);
        showToast('Copy failed', 'error');
      }
    }

    function highlightCopyButton(button) {
      const originalHTML = button.innerHTML;
      const originalClass = button.className;

      button.innerHTML = '<i class="bi bi-check"></i> Copied!';
      button.classList.remove('btn-outline-secondary');
      button.classList.add('btn-success');

      setTimeout(() => {
        button.innerHTML = originalHTML;
        button.className = originalClass;
      }, 2000);
    }
  });
  // Calendar Management Class (Restored Original Logic)
  class CalendarManager {
    constructor() {
      this.today = new Date();
      this.minDate = this.addDays(this.today, CONFIG.MIN_ADVANCE_DAYS);
      this.maxDate = this.addDays(this.today, CONFIG.MAX_ADVANCE_DAYS);

      // Allow viewing past requests - start from 6 months before today
      this.viewMinDate = this.addDays(this.today, -180);
      // Allow viewing 1 month after request period
      this.viewMaxDate = this.addDays(this.maxDate, 30);

      // Start with middle month (October) in the center position
      const middleDate = new Date(
        (this.minDate.getTime() + this.maxDate.getTime()) / 2
      );
      this.currentViewStart = new Date(
        middleDate.getFullYear(),
        middleDate.getMonth() - 1, // Subtract 1 to show October as middle month
        1
      );
      this.monthsToShow = 3;
    }

    addDays(date, days) {
      const result = new Date(date);
      result.setDate(result.getDate() + days);
      return result;
    }

    getMonthsToDisplay() {
      const months = [];
      let current = new Date(this.currentViewStart);

      for (let i = 0; i < this.monthsToShow; i++) {
        months.push(new Date(current));
        current.setMonth(current.getMonth() + 1);
      }

      return months;
    }

    canNavigatePrevious() {
      const previousMonth = new Date(this.currentViewStart);
      previousMonth.setMonth(previousMonth.getMonth() - 1);
      const viewMinMonth = new Date(
        this.viewMinDate.getFullYear(),
        this.viewMinDate.getMonth(),
        1
      );
      return previousMonth >= viewMinMonth;
    }

    canNavigateNext() {
      const lastDisplayedMonth = new Date(this.currentViewStart);
      lastDisplayedMonth.setMonth(
        lastDisplayedMonth.getMonth() + this.monthsToShow - 1
      );
      const viewMaxMonth = new Date(
        this.viewMaxDate.getFullYear(),
        this.viewMaxDate.getMonth(),
        1
      );
      return lastDisplayedMonth < viewMaxMonth;
    }

    navigatePrevious() {
      if (this.canNavigatePrevious()) {
        this.currentViewStart.setMonth(this.currentViewStart.getMonth() - 1);
        this.generateCalendar();
        this.updateNavigationButtons();
      }
    }

    navigateNext() {
      if (this.canNavigateNext()) {
        this.currentViewStart.setMonth(this.currentViewStart.getMonth() + 1);
        this.generateCalendar();
        this.updateNavigationButtons();
      }
    }

    updateNavigationButtons() {
      const prevBtn = document.getElementById('prevMonthBtn');
      const nextBtn = document.getElementById('nextMonthBtn');
      const currentDisplay = document.getElementById('currentMonthDisplay');

      if (prevBtn) prevBtn.disabled = !this.canNavigatePrevious();
      if (nextBtn) nextBtn.disabled = !this.canNavigateNext();

      // Update current month display
      const months = this.getMonthsToDisplay();
      const startMonth = months[0].toLocaleDateString('en-US', {
        month: 'short',
        year: 'numeric',
      });
      const endMonth = months[months.length - 1].toLocaleDateString('en-US', {
        month: 'short',
        year: 'numeric',
      });
      if (currentDisplay) {
        currentDisplay.textContent = `${startMonth} - ${endMonth}`;
      }
    }

    isDateAvailable(date) {
      return date >= this.minDate && date <= this.maxDate;
    }

    isWeekend(date) {
      const day = date.getDay();
      return day === 0 || day === 6;
    }

    formatDate(date) {
      // DST-safe date formatting
      const utcDate = new Date(
        Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())
      );
      return utcDate.toISOString().split('T')[0];
    }

    generateCalendar() {
      const calendarGrid = document.getElementById('calendarGrid');
      if (!calendarGrid) {
        console.error('Calendar container not found!');
        return;
      }

      calendarGrid.innerHTML = '';

      const months = this.getMonthsToDisplay();

      months.forEach((monthStart) => {
        const monthContainer = this.createMonthContainer(monthStart);
        calendarGrid.appendChild(monthContainer);
      });

      this.updateNavigationButtons();
      this.updateDateSelection();
    }

    createMonthContainer(monthStart) {
      const monthContainer = document.createElement('div');
      monthContainer.className = 'month-container';

      // Month header
      const monthHeader = document.createElement('div');
      monthHeader.className = 'month-header';
      monthHeader.textContent = monthStart.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric',
      });

      // Weekday headers
      const weekdayHeader = document.createElement('div');
      weekdayHeader.className = 'weekday-header';
      ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].forEach((day) => {
        const dayElement = document.createElement('div');
        dayElement.className = 'weekday';
        dayElement.textContent = day;
        weekdayHeader.appendChild(dayElement);
      });

      // Days grid
      const daysGrid = document.createElement('div');
      daysGrid.className = 'days-grid';

      const firstDay = new Date(
        monthStart.getFullYear(),
        monthStart.getMonth(),
        1
      );
      const startDate = new Date(firstDay);
      let dayOfWeek = firstDay.getDay();
      dayOfWeek = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      startDate.setDate(startDate.getDate() - dayOfWeek);

      for (let i = 0; i < 42; i++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + i);
        const isCurrentMonth = currentDate.getMonth() === monthStart.getMonth();
        const dayCell = this.createDayCell(
          currentDate,
          monthStart,
          isCurrentMonth
        );
        daysGrid.appendChild(dayCell);
      }

      monthContainer.appendChild(monthHeader);
      monthContainer.appendChild(weekdayHeader);
      monthContainer.appendChild(daysGrid);

      return monthContainer;
    }

    createDayCell(date, monthStart, shouldShowDate) {
      const dayCell = document.createElement('div');
      dayCell.className = 'day-cell';
      dayCell.dataset.date = this.formatDate(date);

      if (!shouldShowDate) {
        dayCell.style.visibility = 'hidden';
        dayCell.style.pointerEvents = 'none';
        return dayCell;
      }

      // Day number
      const dayNumber = document.createElement('div');
      dayNumber.className = 'day-number';
      dayNumber.textContent = date.getDate();

      // Determine cell state
      const isCurrentMonth = date.getMonth() === monthStart.getMonth();
      const isAvailable = this.isDateAvailable(date);
      const isWeekend = this.isWeekend(date);

      if (!isCurrentMonth) {
        dayCell.classList.add('other-month');
      }

      if (isWeekend) {
        dayCell.classList.add('weekend');
      }

      if (!isAvailable) {
        dayCell.classList.add('unavailable');
      } else {
        dayCell.addEventListener('click', () => this.handleDateClick(date));
      }

      // Check for existing requests
      const existingRequest = this.getExistingRequest(date);
      if (existingRequest) {
        const requestElement = document.createElement('div');
        requestElement.className = `day-request request-${existingRequest.status.toLowerCase()}`;

        // Create request content container
        const requestContent = document.createElement('div');
        requestContent.className = 'request-content';

        // Create request type span
        const requestType = document.createElement('span');
        requestType.className = 'request-type';
        requestType.textContent = CONFIG.REQUEST_TYPES[existingRequest.type];

        // ✅ SIMPLIFIED: Only show email status (sent/not sent), not mode
        const emailStatusIcon = document.createElement('span');
        emailStatusIcon.className = 'email-status-icon';

        const emailStatus = this.getSimpleEmailStatus(existingRequest);
        emailStatusIcon.textContent = emailStatus.icon;
        emailStatusIcon.setAttribute('title', emailStatus.title);

        // Append elements
        requestContent.appendChild(requestType);
        requestContent.appendChild(emailStatusIcon);
        requestElement.appendChild(requestContent);

        // Simplified tooltip
        dayCell.setAttribute('data-bs-toggle', 'tooltip');
        dayCell.setAttribute('data-bs-placement', 'top');
        dayCell.setAttribute(
          'title',
          `${this.formatDate(date)}: ${existingRequest.type} (${existingRequest.status}) - ${emailStatus.title}${
            existingRequest.customMessage
              ? ' - ' + existingRequest.customMessage
              : ''
          }`
        );

        // ✅ REMOVED: Email mode indicator (🤖/📧)

        dayCell.appendChild(requestElement);
      }

      dayCell.appendChild(dayNumber);
      return dayCell;
    }
    getSimpleEmailStatus(request) {
      const requestEmailMode = request.emailMode || 'automatic';

      if (requestEmailMode === 'automatic') {
        if (request.emailSent) {
          return { icon: '✅', title: 'Email sent' };
        } else if (request.emailFailed) {
          return { icon: '❌', title: 'Email failed' };
        } else {
          return { icon: '⏳', title: 'Email pending' };
        }
      } else {
        if (request.manualEmailConfirmed) {
          return { icon: '✅', title: 'Email sent' };
        } else {
          return { icon: '📧', title: 'Email ready to send' };
        }
      }
    }

    // Add this helper method to CalendarManager class
    // ✅ UPDATE: Existing getEmailStatusIcon function in CalendarManager class
    getEmailStatusIcon(request) {
      // ✅ Use the request's original emailMode, not the user's current preference
      const requestEmailMode = request.emailMode || 'automatic';

      if (requestEmailMode === 'automatic') {
        if (request.emailSent) {
          return {
            icon: '✅',
            title: 'Email sent automatically',
          };
        } else if (request.emailFailed) {
          return {
            icon: '❌',
            title: 'Email failed to send',
          };
        } else if (request.emailPending) {
          return {
            icon: '🔄',
            title: 'Email sending in progress',
          };
        } else {
          return {
            icon: '⚠️',
            title: 'Email not sent yet',
          };
        }
      } else {
        // Manual mode: Check manual confirmation status
        if (request.manualEmailConfirmed) {
          return {
            icon: '✅',
            title: 'User confirmed email sent',
          };
        } else if (
          request.manualEmailContent &&
          !request.manualEmailConfirmed
        ) {
          return {
            icon: '📧',
            title: 'Email ready to copy and send',
          };
        } else {
          return {
            icon: '⚠️',
            title: 'Email not prepared yet',
          };
        }
      }
    }

    // Alternative simpler version if the above is too complex:
    getEmailStatusIconSimple(request) {
      // Simple fallback that works with current data structure
      if (request.status === 'APPROVED') {
        return {
          icon: '✅',
          title: 'Request approved',
        };
      } else if (request.status === 'DENIED') {
        return {
          icon: '❌',
          title: 'Request denied',
        };
      } else {
        return {
          icon: '📧',
          title: 'Request pending',
        };
      }
    }

    getExistingRequest(date) {
      const dateStr = this.formatDate(date);
      return existingRequests.find(
        (request) =>
          request.startDate === dateStr || request.endDate === dateStr
      );
    }

    handleDateClick(date) {
      if (!this.isDateAvailable(date)) return;

      const dateStr = this.formatDate(date);
      const existingRequest = this.getExistingRequest(date);

      if (existingRequest) {
        // ✅ FIXED: Use the new modal function (remove the old generateRequestDetailContent call)
        window.showRequestDetailModal(existingRequest, dateStr);
        return;
      }

      // Regular date selection logic...
      const index = selectedDates.findIndex((d) => d.date === dateStr);

      if (index > -1) {
        // Deselecting - check if remaining dates stay consecutive
        const tempSelection = [...selectedDates];
        tempSelection.splice(index, 1);

        if (
          tempSelection.length > 1 &&
          !validateConsecutiveDates(tempSelection.map((d) => d.date))
        ) {
          showToast(
            'Removing this date would break consecutive selection. Starting fresh.',
            'warning'
          );
          selectedDates = [];
        } else {
          selectedDates.splice(index, 1);
        }
      } else {
        // Selecting new date
        if (selectedDates.length === 0) {
          selectedDates.push({ date: dateStr, type: 'REQ_DO' });
        } else {
          if (this.isConsecutiveToSelection(dateStr)) {
            if (selectedDates.length >= CONFIG.MAX_DAYS_PER_REQUEST) {
              showToast(
                `Maximum ${CONFIG.MAX_DAYS_PER_REQUEST} consecutive days allowed`,
                'warning'
              );
              return;
            }
            selectedDates.push({ date: dateStr, type: 'REQ_DO' });
          } else {
            selectedDates = [{ date: dateStr, type: 'REQ_DO' }];
            showToast('Started new selection', 'info');
          }
        }
      }

      selectedDates.sort((a, b) => new Date(a.date) - new Date(b.date));

      setTimeout(() => {
        this.updateDateSelection();
        this.updateFloatingButton();
      }, 10);
    }

    // DST-safe consecutive check
    isConsecutiveToSelection(newDateStr) {
      if (selectedDates.length === 0) return true;

      const selectedDateStrings = selectedDates.map((d) => d.date).sort();
      const allDates = [...selectedDateStrings, newDateStr].sort();

      for (let i = 1; i < allDates.length; i++) {
        const prevDate = allDates[i - 1];
        const currentDate = allDates[i];
        const expectedNext = addDays(prevDate, 1);
        if (currentDate !== expectedNext) {
          return false;
        }
      }

      return true;
    }

    updateDateSelection() {
      const allSelected = document.querySelectorAll('.day-cell.selected');
      allSelected.forEach((cell) => cell.classList.remove('selected'));

      selectedDates.forEach(({ date }) => {
        const cells = document.querySelectorAll(`[data-date="${date}"]`);
        cells.forEach((cell) => {
          if (cell.style.visibility !== 'hidden') {
            cell.classList.add('selected');
          }
        });
      });
    }

    updateFloatingButton() {
      const button = document.getElementById('createRequestBtn');
      const buttonText = document.getElementById('requestBtnText');

      if (selectedDates.length > 0) {
        button.classList.add('show');
        if (buttonText) {
          buttonText.textContent = `Create Request (${selectedDates.length} day${selectedDates.length > 1 ? 's' : ''})`;
        }
      } else {
        button.classList.remove('show');
        if (buttonText) {
          buttonText.textContent = 'New Request';
        }
      }
    }
    getStatusColor(status) {
      switch (status) {
        case 'APPROVED':
          return 'success';
        case 'DENIED':
          return 'danger';
        default:
          return 'warning';
      }
    }

    generateGroupEmailContent(request) {
      // Get all requests in the same group
      const groupRequests = existingRequests.filter(
        (r) => r.groupId === request.groupId
      );
      groupRequests.sort(
        (a, b) => new Date(a.startDate) - new Date(b.startDate)
      );

      const firstDate = new Date(groupRequests[0].startDate);
      const month = firstDate.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric',
      });

      // Build the email body
      let bodyLines = ['Dear,', ''];

      groupRequests.forEach((req) => {
        let line = `${req.startDate} - `;

        // Convert type to display format
        switch (req.type) {
          case 'REQ_DO':
            line += 'REQ DO';
            break;
          case 'PM_OFF':
            line += 'PM OFF';
            break;
          case 'AM_OFF':
            line += 'AM OFF';
            break;
          case 'FLIGHT':
            line += 'FLIGHT';
            break;
          default:
            line += req.type;
        }

        if (req.flightNumber) {
          line += ` ${req.flightNumber}`;
        }
        bodyLines.push(line);
      });

      if (request.customMessage) {
        bodyLines.push('');
        bodyLines.push(request.customMessage);
        // ✅ REMOVED: Extra line break after custom message
        // bodyLines.push(''); // <-- Remove this line
      }

      bodyLines.push('');
      bodyLines.push(window.currentUserData?.signature || 'Brgds,\nYour Name');

      return {
        subject: `${window.currentUserData?.code || 'RVB'} - CREW REQUEST - ${month}`,
        body: bodyLines.join('\n'),
      };
    }

    generateEmailContent(request) {
      const startDate = new Date(request.startDate);
      const month = startDate.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric',
      });

      // Build the email body properly
      let bodyLines = ['Dear,', ''];

      // Add the actual request line with proper type display
      let line = `${request.startDate} - `;

      // Convert type to display format
      switch (request.type) {
        case 'REQ_DO':
          line += 'REQ DO';
          break;
        case 'PM_OFF':
          line += 'PM OFF';
          break;
        case 'AM_OFF':
          line += 'AM OFF';
          break;
        case 'FLIGHT':
          line += 'FLIGHT';
          break;
        default:
          line += request.type;
      }

      // Add flight number if exists
      if (request.flightNumber) {
        line += ` ${request.flightNumber}`;
      }

      bodyLines.push(line);

      // Add custom message if exists
      if (request.customMessage) {
        bodyLines.push('');
        bodyLines.push(request.customMessage);
        bodyLines.push(''); // ✅ ADD THIS: Additional line break after custom message
      }

      // 🔥 FIX: Add signature WITHOUT extra "Brgds" prefix
      bodyLines.push('');
      bodyLines.push(window.currentUserData?.signature || 'Brgds,\nYour Name');

      return {
        subject: `${window.currentUserData?.code || 'RVB'} - CREW REQUEST - ${month}`,
        body: bodyLines.join('\n'),
      };
    }
  }

  // Initialize calendar
  const calendar = new CalendarManager();
  window.updateDateType = function (index, newType) {
    // Update the selectedDates array
    selectedDates[index].type = newType;

    // Show/hide flight number input based on selection
    const flightInput = document.querySelector(`input[data-index="${index}"]`);
    if (flightInput) {
      if (newType === 'FLIGHT') {
        flightInput.style.display = 'block';
        flightInput.required = true;
        flightInput.focus();
      } else {
        flightInput.style.display = 'none';
        flightInput.required = false;
        flightInput.value = '';
        selectedDates[index].flightNumber = '';
      }
    }

    // ✅ UPDATE PREVIEW IMMEDIATELY
    updateRequestPreview();
  };

  window.updateFlightNumber = function (index, flightNumber) {
    // Update the selectedDates array
    selectedDates[index].flightNumber = flightNumber;

    // ✅ UPDATE PREVIEW IMMEDIATELY
    updateRequestPreview();
  };
  window.updateRequestPreview = function () {
    const requestLinesContainer = document.getElementById('requestLines');
    const emailSubjectElement = document.getElementById('emailSubject');
    const customMessagePreview = document.getElementById(
      'customMessagePreview'
    );
    const userSignatureElement = document.getElementById('userSignature');

    if (!requestLinesContainer || !emailSubjectElement) return;

    // ✅ FIX: Generate proper request lines from selected dates
    if (selectedDates && selectedDates.length > 0) {
      const requestLines = selectedDates
        .map((dateInfo) => {
          const formattedDate = formatDateForEmail(new Date(dateInfo.date));

          switch (dateInfo.type) {
            case 'REQ_DO':
              return `REQ DO - ${formattedDate}`;
            case 'PM_OFF':
              return `REQ PM OFF - ${formattedDate}`;
            case 'AM_OFF':
              return `REQ AM OFF - ${formattedDate}`;
            case 'FLIGHT':
              return `REQ FLIGHT ${dateInfo.flightNumber || '[NUMBER]'} - ${formattedDate}`; // ✅ FIXED: REQ FLIGHT
            default:
              return `${dateInfo.type} - ${formattedDate}`;
          }
        })
        .join('<br>');

      requestLinesContainer.innerHTML = requestLines;
    } else {
      requestLinesContainer.innerHTML =
        '<em class="text-muted">Please fill in the required fields</em>';
    }

    // ✅ FIX: Generate proper subject with correct format
    if (selectedDates && selectedDates.length > 0) {
      const firstDate = new Date(selectedDates[0].date);
      const monthNames = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
      ];
      const monthName = monthNames[firstDate.getMonth()];
      const year = firstDate.getFullYear();
      const userCode =
        window.currentUserData?.code ||
        window.TUIFLY_CONFIG?.EMPLOYEE_CODE ||
        'XXX';

      emailSubjectElement.textContent = `${userCode} - CREW REQUEST - ${monthName} ${year}`;
    }

    // ✅ FIX: Update custom message preview
    const customMessage = document.getElementById('customMessage');
    const customMessageSpacer = document.getElementById('customMessageSpacer');

    if (customMessage && customMessagePreview) {
      if (customMessage.value.trim()) {
        customMessagePreview.textContent = customMessage.value;
        customMessagePreview.style.display = 'block';

        // ✅ Show spacer to create line break after custom message
        if (customMessageSpacer) {
          customMessageSpacer.style.display = 'block';
        }
      } else {
        customMessagePreview.style.display = 'none';

        // Hide spacer when no custom message
        if (customMessageSpacer) {
          customMessageSpacer.style.display = 'none';
        }
      }
    }

    // ✅ FIX: Update signature properly
    if (userSignatureElement) {
      const signature =
        window.currentUserData?.signature ||
        window.TUIFLY_CONFIG?.EMPLOYEE_SIGNATURE ||
        `Brgds,\n${window.currentUserData?.name || window.TUIFLY_CONFIG?.EMPLOYEE_NAME || 'Unknown'}`;

      userSignatureElement.innerHTML = `<br><br>${signature.replace(/\n/g, '<br>')}`;
    }
  };

  // ✅ ADD: Helper function to format dates properly
  function formatDateForEmail(date) {
    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
  }

  // ✅ CENTRALIZED EMAIL GENERATION (matches gmailService.js)
  function generateEmailContentLikeGmailService(user, requests) {
    const firstRequest = requests[0];
    const startDate = new Date(firstRequest.startDate);

    // Generate subject (matches gmailService)
    const monthNames = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December',
    ];
    const monthName = monthNames[startDate.getMonth()];
    const year = startDate.getFullYear();
    const subject = `${user.code} - CREW REQUEST - ${monthName} ${year}`;

    // Generate request lines (matches gmailService format)
    const requestLines = requests
      .map((request) => {
        const start = new Date(request.startDate);
        const end = new Date(request.endDate);
        const dates = [];

        // Generate all dates in range
        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
          dates.push(new Date(d));
        }

        return dates
          .map((date) => {
            const formattedDate = `${date.getDate().toString().padStart(2, '0')}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getFullYear()}`;

            switch (request.type) {
              case 'REQ_DO':
                return `REQ DO - ${formattedDate}`;
              case 'PM_OFF':
                return `REQ PM OFF - ${formattedDate}`;
              case 'AM_OFF':
                return `REQ AM OFF - ${formattedDate}`;
              case 'FLIGHT':
                return `FLIGHT ${request.flightNumber || ''} - ${formattedDate}`;
              default:
                return `${request.type} - ${formattedDate}`;
            }
          })
          .join('\n');
      })
      .join('\n');

    return {
      subject: subject,
      requestLines: requestLines,
      body: `Dear,\n\n${requestLines}${firstRequest.customMessage ? '\n\n' + firstRequest.customMessage : ''}\n\n${user.signature}`,
    };
  }

  // ✅ ADD DYNAMIC UPDATE EVENT LISTENERS
  document.addEventListener('DOMContentLoaded', function () {
    const fieldsToWatch = [
      'startDate',
      'endDate',
      'type',
      'flightNumber',
      'customMessage',
    ];
    fieldsToWatch.forEach((fieldId) => {
      const field = document.getElementById(fieldId);
      if (field) {
        field.addEventListener('change', updateRequestPreview);
        field.addEventListener('input', updateRequestPreview);
      }
    });
  });
  window.loadGroupEmailContent = async function (requestId) {
    try {
      const response = await fetch(
        `/api/requests/${requestId}/group-email-content`
      );
      const result = await response.json();

      if (result.success) {
        const emailContent = result.data.emailContent;

        // Populate the form fields
        document.getElementById('emailSubject').value = emailContent.subject;
        document.getElementById('emailBody').value = emailContent.body;

        // Show the content
        document.getElementById('emailContentDisplay').style.display = 'block';

        showToast(
          result.data.isGroup
            ? 'Group email content generated'
            : 'Email content generated',
          'success'
        );
      } else {
        showToast(result.error || 'Failed to generate email content', 'error');
      }
    } catch (error) {
      console.error('Error loading email content:', error);
      showToast('Failed to generate email content', 'error');
    }
  };
  // DST-safe date utility
  function addDays(dateStr, days) {
    const parts = dateStr.split('-');
    const date = new Date(
      parseInt(parts[0]),
      parseInt(parts[1]) - 1,
      parseInt(parts[2])
    );
    date.setDate(date.getDate() + days);
    const utcDate = new Date(
      Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())
    );
    return utcDate.toISOString().split('T')[0];
  }

  // Enhanced consecutive date validation
  function validateConsecutiveDates(dates) {
    if (dates.length <= 1) return true;

    const sortedDates = [...dates].sort();
    for (let i = 1; i < sortedDates.length; i++) {
      const expectedDate = addDays(sortedDates[i - 1], 1);
      if (sortedDates[i] !== expectedDate) {
        return false;
      }
    }
    return true;
  }

  // API Functions
  async function loadExistingRequests() {
    try {
      const response = await fetch('/api/requests');
      const data = await response.json();

      if (data.success) {
        existingRequests = data.data;
        updateStatistics(data.data);
        calendar.generateCalendar();
        initializeTooltips();
      }
    } catch (error) {
      console.error('Error loading requests:', error);
      showToast('Failed to load existing requests', 'error');
    }
  }

  function updateStatistics(requests) {
    const pending = requests.filter((r) => r.status === 'PENDING').length;
    const approved = requests.filter((r) => r.status === 'APPROVED').length;
    const denied = requests.filter((r) => r.status === 'DENIED').length;

    document.getElementById('pendingCount').textContent = pending;
    document.getElementById('approvedCount').textContent = approved;
    document.getElementById('deniedCount').textContent = denied;
    document.getElementById('totalCount').textContent = requests.length;
  }

  function initializeTooltips() {
    const tooltipTriggerList = [].slice.call(
      document.querySelectorAll('[data-bs-toggle="tooltip"]')
    );
    tooltipTriggerList.map(
      (tooltipTriggerEl) => new bootstrap.Tooltip(tooltipTriggerEl)
    );
  }

  // Modal Functions
  function openGroupRequestModal() {
    if (selectedDates.length === 0) {
      showToast('Please select dates first', 'warning');
      return;
    }

    // Create modal if it doesn't exist
    let modal = document.getElementById('groupRequestModal');
    if (!modal) {
      createGroupRequestModal();
      modal = document.getElementById('groupRequestModal');
    }

    // Populate dates in modal
    populateModalDates();

    // Show modal
    const bootstrapModal = new bootstrap.Modal(modal);
    bootstrapModal.show();

    // ✅ Initialize email preview and add dynamic listeners after modal is visible
    setTimeout(() => {
      updateRequestPreview(); // Initial preview
      addDynamicPreviewListeners(); // Add change listeners
    }, 200); // Increased timeout to ensure elements are ready
  }

  function addDynamicPreviewListeners() {
    // Find all the date type dropdowns and flight number inputs
    const dateInputs = document.querySelectorAll(
      'select[id^="dateType_"], input[id^="flightNumber_"]'
    );

    dateInputs.forEach((input) => {
      input.addEventListener('change', function () {
        // Update the selectedDates array with the new values
        updateSelectedDatesFromInputs();
        // Trigger preview update
        updateRequestPreview();
      });
    });

    // Also listen to custom message changes
    const customMessageInput = document.getElementById('customMessage');
    if (customMessageInput) {
      customMessageInput.addEventListener('input', function () {
        updateRequestPreview();
      });
    }
  }

  // ✅ ADD: Function to update selectedDates array from current input values
  function updateSelectedDatesFromInputs() {
    selectedDates.forEach((dateInfo, index) => {
      const typeSelect = document.getElementById(`dateType_${index}`);
      const flightInput = document.getElementById(`flightNumber_${index}`);

      if (typeSelect) {
        dateInfo.type = typeSelect.value;
      }

      if (flightInput && dateInfo.type === 'FLIGHT') {
        dateInfo.flightNumber = flightInput.value;
      }
    });
  }

  function createGroupRequestModal() {
    const modalHTML = `
        <div class="modal fade" id="groupRequestModal" tabindex="-1">
          <div class="modal-dialog modal-lg">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title">
                  <i class="bi bi-calendar-plus"></i> Create Time-Off Request
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
              </div>
              <div class="modal-body">
                <form id="groupRequestForm">
                  <div class="mb-3">
                    <label class="form-label">Selected Dates</label>
                    <div id="selectedDatesList" class="border rounded p-3 bg-light">
                      <!-- Dates will be populated here -->
                    </div>
                  </div>

                  <div class="mb-3">
                    <label for="customMessage" class="form-label">Custom Message (Optional)</label>
                    <textarea
                      class="form-control"
                      id="customMessage"
                      rows="3"
                      placeholder="Additional information or reason for time-off...">
                    </textarea>
                  </div>

                  <div class="alert alert-info">
                    <i class="bi bi-info-circle me-2"></i>
                    <small>
                      Request will be sent to scheduling@tuifly.be for approval.
                    </small>
                  </div>
                </form>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="submitGroupRequest">
                  <i class="bi bi-send me-1"></i>Submit Request
                </button>
              </div>
            </div>
          </div>
        </div>
      `;
    document.body.insertAdjacentHTML('beforeend', modalHTML);
  }

  function populateModalDates() {
    const container = document.getElementById('selectedDatesList');
    container.innerHTML = '';

    selectedDates.forEach((dateObj, index) => {
      const date = new Date(dateObj.date);
      const dateStr = date.toLocaleDateString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      });

      const dateRow = document.createElement('div');
      dateRow.className = 'row mb-2 align-items-center';
      const isFlightType = dateObj.type === 'FLIGHT';

      dateRow.innerHTML = `
  <div class="col-md-6">
    <span class="fw-bold">${dateStr}</span>
  </div>
  <div class="col-md-4">
    <select class="form-select form-select-sm" onchange="updateDateType(${index}, this.value)">
      <option value="REQ_DO" ${dateObj.type === 'REQ_DO' ? 'selected' : ''}>Full Day Off</option>
      <option value="PM_OFF" ${dateObj.type === 'PM_OFF' ? 'selected' : ''}>PM Off</option>
      <option value="AM_OFF" ${dateObj.type === 'AM_OFF' ? 'selected' : ''}>AM Off</option>
      <option value="FLIGHT" ${dateObj.type === 'FLIGHT' ? 'selected' : ''}>Flight</option>
    </select>
  </div>
  <div class="col-md-2">
    <input 
      type="text" 
      class="form-control form-control-sm" 
      placeholder="Flight#"
      data-index="${index}"
      value="${dateObj.flightNumber || ''}"
      onchange="updateFlightNumber(${index}, this.value)"
      oninput="updateFlightNumber(${index}, this.value)"
      style="display: ${isFlightType ? 'block' : 'none'}"
      ${isFlightType ? 'required' : ''}
    />
  </div>
`;

      container.appendChild(dateRow);
    });
  }

  function updateDateType(index, type) {
    selectedDates[index].type = type;

    const flightInput = document.getElementById(`flight-${index}`);
    if (type === 'FLIGHT') {
      flightInput.style.display = 'block';
      flightInput.disabled = false;
      flightInput.required = true;
      flightInput.focus();
    } else {
      flightInput.style.display = 'none';
      flightInput.disabled = true;
      flightInput.required = false;
      selectedDates[index].flightNumber = '';
    }
  }

  function updateFlightNumber(index, flightNumber) {
    selectedDates[index].flightNumber = flightNumber;
  }

  async function submitGroupRequest() {
    if (isSubmitting) return;

    const customMessage = document.getElementById('customMessage').value.trim();
    const submitButton = document.getElementById('submitGroupRequest');

    // Validate flight numbers
    const flightDates = selectedDates.filter((d) => d.type === 'FLIGHT');
    for (const date of flightDates) {
      if (!date.flightNumber || !date.flightNumber.startsWith('TB')) {
        showToast('Flight numbers must start with "TB"', 'error');
        return;
      }
    }

    if (!validateConsecutiveDates(selectedDates.map((d) => d.date))) {
      showToast('Selected dates must be consecutive', 'error');
      return;
    }

    if (selectedDates.length === 0) return;

    isSubmitting = true;
    submitButton.disabled = true;
    submitButton.innerHTML =
      '<i class="bi bi-hourglass-split me-1"></i>Submitting...';

    try {
      const response = await fetch('/api/requests/group', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          dates: selectedDates,
          customMessage: customMessage || null,
        }),
      });

      const result = await response.json();

      if (result.success) {
        const modal = bootstrap.Modal.getInstance(
          document.getElementById('groupRequestModal')
        );
        modal.hide();

        selectedDates = [];
        calendar.updateDateSelection();
        calendar.updateFloatingButton();

        await loadExistingRequests();
        showToast(result.message, 'success');
      } else {
        showToast(result.error, 'error');
      }
    } catch (error) {
      console.error('Error creating group request:', error);
      showToast('Failed to create request', 'error');
    } finally {
      isSubmitting = false;
      submitButton.disabled = false;
      submitButton.innerHTML = '<i class="bi bi-send me-1"></i>Submit Request';
    }
  }

  // Event Listeners
  document.addEventListener('DOMContentLoaded', async () => {
    await loadUserDataAndSettings();
    await loadExistingRequests();
    try {
      const response = await fetch('/settings/email-preference');
      const data = await response.json();
      if (data.success && typeof loadEmailPreferences === 'function') {
        loadEmailPreferences(data.data);
      }
    } catch (error) {
      console.log('Could not load email preferences for header badge');
    }
    const createBtn = document.getElementById('createRequestBtn');
    if (createBtn && !createBtn.hasAttribute('data-listener-added')) {
      createBtn.addEventListener('click', openGroupRequestModal);
      createBtn.setAttribute('data-listener-added', 'true');
    }

    const prevBtn = document.getElementById('prevMonthBtn');
    const nextBtn = document.getElementById('nextMonthBtn');

    if (prevBtn && !prevBtn.hasAttribute('data-listener-added')) {
      prevBtn.addEventListener('click', () => calendar.navigatePrevious());
      prevBtn.setAttribute('data-listener-added', 'true');
    }

    if (nextBtn && !nextBtn.hasAttribute('data-listener-added')) {
      nextBtn.addEventListener('click', () => calendar.navigateNext());
      nextBtn.setAttribute('data-listener-added', 'true');
    }

    document.addEventListener('click', (e) => {
      if (e.target.id === 'submitGroupRequest') {
        e.preventDefault();
        submitGroupRequest();
      }
    });

    document.addEventListener('hidden.bs.modal', (e) => {
      if (e.target.id === 'groupRequestModal') {
        document.getElementById('groupRequestForm')?.reset();
        const customMessage = document.getElementById('customMessage');
        if (customMessage) customMessage.value = '';
        isSubmitting = false;
      }
    });
  });

  // Toast notification function
  function showToast(message, type = 'info') {
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.className =
        'toast-container position-fixed top-0 end-0 p-3';
      toastContainer.style.zIndex = '1055';
      document.body.appendChild(toastContainer);
    }

    const toastId = 'toast_' + Date.now();
    const bgClass =
      type === 'success'
        ? 'bg-success'
        : type === 'error'
          ? 'bg-danger'
          : type === 'warning'
            ? 'bg-warning'
            : 'bg-info';

    const toastHTML = `
          <div id="${toastId}" class="toast ${bgClass} text-white" role="alert">
            <div class="d-flex">
              <div class="toast-body">${message}</div>
              <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
          </div>
        `;

    toastContainer.insertAdjacentHTML('beforeend', toastHTML);

    const toastElement = document.getElementById(toastId);
    const toast = new bootstrap.Toast(toastElement, {
      autohide: true,
      delay: type === 'error' ? 5000 : 3000,
    });
    toast.show();

    toastElement.addEventListener('hidden.bs.toast', () => {
      toastElement.remove();
    });
  }
  function getEmailStatusTooltip(request) {
    const status = getEmailStatusIcon(request);
    const tooltipMap = {
      '✅':
        request.emailMode === 'automatic'
          ? 'Email sent successfully'
          : 'Email confirmed sent',
      '❌': 'Email failed to send',
      '🔄': 'Email sending in progress',
      '📧': 'Email ready to copy',
      '⚠️': 'Email not sent yet',
      '❓': 'Unknown email status',
    };
    return tooltipMap[status] || 'Unknown email status';
  }
  // ➕ UTILITY FUNCTIONS
  function formatDisplayDate(dateString) {
    return new Date(dateString).toLocaleDateString('en-GB');
  }

  function getStatusColor(status) {
    const colors = {
      PENDING: 'warning',
      APPROVED: 'success',
      DENIED: 'danger',
    };
    return colors[status] || 'secondary';
  }

  // 🔍 FIND where request elements get click handlers and ADD this to show the detail modal:
  // Look for: requestElement.addEventListener('click', ...) or similar and MODIFY to:
  // (This should be added to the existing request element creation)

  // Add click handler to show request details (modify existing click handler)
  requestElement.addEventListener('click', (e) => {
    e.stopPropagation();
    showRequestDetailModal(existingRequest);
  });
</script>
