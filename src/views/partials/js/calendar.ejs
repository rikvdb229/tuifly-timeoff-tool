<!-- src/views/partials/js/calendar.ejs -->
<script>
  // Configuration from meta tags
  const CONFIG = {
    MIN_ADVANCE_DAYS: parseInt(
      document.querySelector('meta[name="min-advance-days"]')?.content || 60
    ),
    MAX_ADVANCE_DAYS: parseInt(
      document.querySelector('meta[name="max-advance-days"]')?.content || 120
    ),
    MAX_DAYS_PER_REQUEST: parseInt(
      document.querySelector('meta[name="max-days-per-request"]')?.content || 4
    ),
    REQUEST_TYPES: {
      REQ_DO: 'Day Off',
      PM_OFF: 'PM Off',
      AM_OFF: 'AM Off',
      FLIGHT: 'Flight',
    },
  };

  // Global state
  let existingRequests = [];
  let selectedDates = [];

  // Calendar Management Class
  class CalendarManager {
    constructor() {
      this.today = new Date();
      this.minDate = this.addDays(this.today, CONFIG.MIN_ADVANCE_DAYS);
      this.maxDate = this.addDays(this.today, CONFIG.MAX_ADVANCE_DAYS);

      // Allow viewing past requests - start from 3 months before today
      this.viewMinDate = this.addDays(this.today, -90);
      this.viewMaxDate = this.maxDate;

      this.currentViewStart = new Date(
        this.minDate.getFullYear(),
        this.minDate.getMonth(),
        1
      );
      this.monthsToShow = 3;

      console.log('üìÖ Calendar date ranges:', {
        today: this.today.toISOString().split('T')[0],
        minDate: this.minDate.toISOString().split('T')[0],
        maxDate: this.maxDate.toISOString().split('T')[0],
        viewMinDate: this.viewMinDate.toISOString().split('T')[0],
        viewMaxDate: this.viewMaxDate.toISOString().split('T')[0],
      });
    }

    addDays(date, days) {
      const result = new Date(date);
      result.setDate(result.getDate() + days);
      return result;
    }

    getMonthsToDisplay() {
      const months = [];
      let current = new Date(this.currentViewStart);

      for (let i = 0; i < this.monthsToShow; i++) {
        months.push(new Date(current));
        current.setMonth(current.getMonth() + 1);
      }

      return months;
    }

    canNavigatePrevious() {
      const previousMonth = new Date(this.currentViewStart);
      previousMonth.setMonth(previousMonth.getMonth() - 1);
      const viewMinMonth = new Date(
        this.viewMinDate.getFullYear(),
        this.viewMinDate.getMonth(),
        1
      );
      const canNavigate = previousMonth >= viewMinMonth;
      console.log('üîç Can navigate previous:', canNavigate, {
        previousMonth: previousMonth.toISOString().split('T')[0],
        viewMinMonth: viewMinMonth.toISOString().split('T')[0],
      });
      return canNavigate;
    }

    canNavigateNext() {
      const lastDisplayedMonth = new Date(this.currentViewStart);
      lastDisplayedMonth.setMonth(
        lastDisplayedMonth.getMonth() + this.monthsToShow - 1
      );
      const viewMaxMonth = new Date(
        this.viewMaxDate.getFullYear(),
        this.viewMaxDate.getMonth(),
        1
      );
      const canNavigate = lastDisplayedMonth < viewMaxMonth;
      console.log('üîç Can navigate next:', canNavigate, {
        lastDisplayedMonth: lastDisplayedMonth.toISOString().split('T')[0],
        viewMaxMonth: viewMaxMonth.toISOString().split('T')[0],
      });
      return canNavigate;
    }

    navigatePrevious() {
      console.log('üîÑ Attempting to navigate previous...');
      if (this.canNavigatePrevious()) {
        this.currentViewStart.setMonth(this.currentViewStart.getMonth() - 1);
        console.log(
          '‚úÖ Navigated to previous month:',
          this.currentViewStart.toISOString().split('T')[0]
        );
        this.generateCalendar();
        this.updateNavigationButtons();
      } else {
        console.log('‚ùå Cannot navigate to previous month');
      }
    }

    navigateNext() {
      console.log('üîÑ Attempting to navigate next...');
      if (this.canNavigateNext()) {
        this.currentViewStart.setMonth(this.currentViewStart.getMonth() + 1);
        console.log(
          '‚úÖ Navigated to next month:',
          this.currentViewStart.toISOString().split('T')[0]
        );
        this.generateCalendar();
        this.updateNavigationButtons();
      } else {
        console.log('‚ùå Cannot navigate to next month');
      }
    }

    updateNavigationButtons() {
      const prevBtn = document.getElementById('prevMonthBtn');
      const nextBtn = document.getElementById('nextMonthBtn');
      const currentDisplay = document.getElementById('currentMonthDisplay');

      if (prevBtn) {
        prevBtn.disabled = !this.canNavigatePrevious();
        console.log('üîÑ Previous button disabled:', prevBtn.disabled);
      }

      if (nextBtn) {
        nextBtn.disabled = !this.canNavigateNext();
        console.log('üîÑ Next button disabled:', nextBtn.disabled);
      }

      // Update current month display
      if (currentDisplay) {
        const months = this.getMonthsToDisplay();
        const startMonth = months[0].toLocaleDateString('en-US', {
          month: 'short',
          year: 'numeric',
        });
        const endMonth = months[months.length - 1].toLocaleDateString('en-US', {
          month: 'short',
          year: 'numeric',
        });
        currentDisplay.textContent = `${startMonth} - ${endMonth}`;
      }
    }

    isDateAvailable(date) {
      return date >= this.minDate && date <= this.maxDate;
    }

    isWeekend(date) {
      const day = date.getDay();
      // Saturday = 6, Sunday = 0
      return day === 0 || day === 6;
    }

    formatDate(date) {
      return date.toISOString().split('T')[0];
    }

    generateCalendar() {
      console.log('=== GENERATING CALENDAR ===');
      const calendarGrid = document.getElementById('calendarGrid');
      if (!calendarGrid) {
        console.error('‚ùå Calendar grid element not found');
        return;
      }

      calendarGrid.innerHTML = '';

      const months = this.getMonthsToDisplay();
      console.log(
        'Displaying months:',
        months.map((m) =>
          m.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })
        )
      );

      // Create month containers
      months.forEach((monthStart, index) => {
        console.log(
          `Creating month ${index + 1}:`,
          monthStart.toLocaleDateString('en-US', {
            month: 'long',
            year: 'numeric',
          })
        );
        const monthContainer = this.createMonthContainer(monthStart);
        calendarGrid.appendChild(monthContainer);
      });

      this.updateNavigationButtons();

      // Use requestAnimationFrame for better timing
      requestAnimationFrame(() => {
        console.log('Running delayed selection update...');
        this.updateDateSelection();
      });

      console.log('=== CALENDAR GENERATION COMPLETE ===');
    }

    createMonthContainer(monthStart) {
      const monthContainer = document.createElement('div');
      monthContainer.className = 'month-container';

      // Month header
      const monthHeader = document.createElement('div');
      monthHeader.className = 'month-header';
      monthHeader.textContent = monthStart.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric',
      });

      // Weekday headers - MONDAY START
      const weekdayHeader = document.createElement('div');
      weekdayHeader.className = 'weekday-header';
      ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].forEach((day) => {
        const dayElement = document.createElement('div');
        dayElement.className = 'weekday';
        dayElement.textContent = day;
        weekdayHeader.appendChild(dayElement);
      });

      // Days grid
      const daysGrid = document.createElement('div');
      daysGrid.className = 'days-grid';

      const firstDay = new Date(
        monthStart.getFullYear(),
        monthStart.getMonth(),
        1
      );

      // Calculate start date for Monday-based week
      const startDate = new Date(firstDay);
      // Get day of week (0 = Sunday, 1 = Monday, etc.)
      let dayOfWeek = firstDay.getDay();
      // Convert to Monday-based (0 = Monday, 1 = Tuesday, etc.)
      dayOfWeek = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      // Go back to the Monday of the week containing the 1st
      startDate.setDate(startDate.getDate() - dayOfWeek);

      for (let i = 0; i < 42; i++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + i);

        // Only show dates that belong to this specific month
        const isCurrentMonth = currentDate.getMonth() === monthStart.getMonth();

        const dayCell = this.createDayCell(
          currentDate,
          monthStart,
          isCurrentMonth
        );
        daysGrid.appendChild(dayCell);
      }

      monthContainer.appendChild(monthHeader);
      monthContainer.appendChild(weekdayHeader);
      monthContainer.appendChild(daysGrid);

      return monthContainer;
    }

    createDayCell(date, monthStart, shouldShowDate) {
      const dayCell = document.createElement('div');
      dayCell.className = 'day-cell';
      dayCell.dataset.date = this.formatDate(date);

      if (!shouldShowDate) {
        // Make cell invisible but keep in DOM for grid layout
        dayCell.style.visibility = 'hidden';
        dayCell.style.pointerEvents = 'none';
        return dayCell;
      }

      // Day number
      const dayNumber = document.createElement('div');
      dayNumber.className = 'day-number';
      dayNumber.textContent = date.getDate();

      // Determine cell state
      const isCurrentMonth = date.getMonth() === monthStart.getMonth();
      const isAvailable = this.isDateAvailable(date);
      const isWeekend = this.isWeekend(date);

      if (!isCurrentMonth) {
        dayCell.classList.add('other-month');
      }

      // Add weekend class BEFORE availability check
      if (isWeekend) {
        dayCell.classList.add('weekend');
      }

      if (!isAvailable) {
        dayCell.classList.add('unavailable');
      } else {
        dayCell.addEventListener('click', () => this.handleDateClick(date));
      }

      // Check for existing requests
      const existingRequest = this.getExistingRequest(date);
      if (existingRequest) {
        const requestElement = document.createElement('div');
        requestElement.className = `day-request request-${existingRequest.status.toLowerCase()}`;
        requestElement.textContent = CONFIG.REQUEST_TYPES[existingRequest.type];

        // Add tooltip
        dayCell.setAttribute('data-bs-toggle', 'tooltip');
        dayCell.setAttribute('data-bs-placement', 'top');
        dayCell.setAttribute(
          'title',
          `${this.formatDate(date)}: ${existingRequest.type} (${existingRequest.status})${
            existingRequest.customMessage
              ? ' - ' + existingRequest.customMessage
              : ''
          }`
        );

        dayCell.appendChild(requestElement);
      }

      dayCell.appendChild(dayNumber);
      return dayCell;
    }

    getExistingRequest(date) {
      const dateStr = this.formatDate(date);
      return existingRequests.find(
        (request) =>
          request.startDate === dateStr || request.endDate === dateStr
      );
    }

    handleDateClick(date) {
      if (!this.isDateAvailable(date)) return;

      const dateStr = this.formatDate(date);
      const existingRequest = this.getExistingRequest(date);

      if (existingRequest) {
        showToast(`Request already exists for ${dateStr}`, 'info');
        return;
      }

      // Handle smart date selection
      const index = selectedDates.findIndex((d) => d.date === dateStr);

      if (index > -1) {
        // Date is already selected - deselect it
        selectedDates.splice(index, 1);
        console.log('Deselected:', dateStr);
      } else {
        // Date is not selected - check if we should add or start fresh
        if (selectedDates.length === 0) {
          // First date - always allow
          selectedDates.push({ date: dateStr, type: 'REQ_DO' });
          console.log('First selection:', dateStr);
        } else {
          // Check if new date extends the consecutive range
          if (this.isConsecutiveToSelection(dateStr)) {
            // Check if we're at the limit
            if (selectedDates.length >= CONFIG.MAX_DAYS_PER_REQUEST) {
              showToast(
                `Maximum ${CONFIG.MAX_DAYS_PER_REQUEST} consecutive days allowed`,
                'warning'
              );
              return;
            }
            // Add to existing selection
            selectedDates.push({ date: dateStr, type: 'REQ_DO' });
            console.log(
              'Extended selection:',
              dateStr,
              'Total:',
              selectedDates.length
            );
          } else {
            // Start fresh selection - clear previous dates and select new one
            selectedDates = [{ date: dateStr, type: 'REQ_DO' }];
            showToast('Started new selection', 'info');
            console.log('Fresh selection:', dateStr);
          }
        }
      }

      // Sort dates chronologically
      selectedDates.sort((a, b) => new Date(a.date) - new Date(b.date));

      // Force update after a small delay to ensure DOM is ready
      setTimeout(() => {
        this.updateDateSelection();
        this.updateFloatingButton();
      }, 10);
    }

    // New method to check if a date is consecutive to current selection
    isConsecutiveToSelection(newDateStr) {
      if (selectedDates.length === 0) return true;

      // Get all selected dates sorted
      const selectedDateStrings = selectedDates.map((d) => d.date).sort();
      const newDate = new Date(newDateStr);

      // Get min and max dates from current selection
      const minDateStr = selectedDateStrings[0];
      const maxDateStr = selectedDateStrings[selectedDateStrings.length - 1];

      const minDate = new Date(minDateStr);
      const maxDate = new Date(maxDateStr);

      // Check if newDate is exactly one day before min or one day after max
      const dayBefore = new Date(minDate);
      dayBefore.setDate(dayBefore.getDate() - 1);

      const dayAfter = new Date(maxDate);
      dayAfter.setDate(dayAfter.getDate() + 1);

      const isOneDayBefore = newDate.getTime() === dayBefore.getTime();
      const isOneDayAfter = newDate.getTime() === dayAfter.getTime();

      return isOneDayBefore || isOneDayAfter;
    }

    // updateDateSelection with better debugging
    updateDateSelection() {
      console.log('=== UPDATE SELECTION ===');
      console.log(
        'Selected dates:',
        selectedDates.map((d) => d.date)
      );

      // Clear all selections first
      const allSelected = document.querySelectorAll('.day-cell.selected');
      console.log('Clearing', allSelected.length, 'previously selected cells');
      allSelected.forEach((cell) => {
        cell.classList.remove('selected');
      });

      // Apply current selections
      selectedDates.forEach(({ date }) => {
        // Find all cells with this date (should be only one, but let's be thorough)
        const cells = document.querySelectorAll(`[data-date="${date}"]`);
        console.log(`Looking for date ${date}: found ${cells.length} cell(s)`);

        cells.forEach((cell, index) => {
          if (cell.style.visibility !== 'hidden') {
            cell.classList.add('selected');
            console.log(`  - Highlighted cell ${index + 1} for ${date}`);
          } else {
            console.log(`  - Skipped hidden cell ${index + 1} for ${date}`);
          }
        });
      });

      console.log('=== SELECTION UPDATE COMPLETE ===');
    }

    updateFloatingButton() {
      const button = document.getElementById('createRequestBtn');
      const buttonText = document.getElementById('requestBtnText');

      if (selectedDates.length > 0) {
        button.classList.add('show');
        if (buttonText) {
          buttonText.textContent = `Create Request (${selectedDates.length} day${selectedDates.length > 1 ? 's' : ''})`;
        }
      } else {
        button.classList.remove('show');
        if (buttonText) {
          buttonText.textContent = 'New Request';
        }
      }
    }
  }

  // Initialize calendar
  let calendar;

  // API Functions
  async function loadExistingRequests() {
    try {
      const response = await fetch('/api/requests');
      const data = await response.json();

      if (data.success) {
        existingRequests = data.data;
        updateStatistics(data.data);
        if (calendar) {
          calendar.generateCalendar();
          initializeTooltips();
        }
      }
    } catch (error) {
      console.error('Error loading requests:', error);
      showToast('Failed to load existing requests', 'error');
    }
  }

  function updateStatistics(requests) {
    const pending = requests.filter((r) => r.status === 'PENDING').length;
    const approved = requests.filter((r) => r.status === 'APPROVED').length;
    const denied = requests.filter((r) => r.status === 'DENIED').length;

    document.getElementById('pendingCount').textContent = pending;
    document.getElementById('approvedCount').textContent = approved;
    document.getElementById('deniedCount').textContent = denied;
    document.getElementById('totalCount').textContent = requests.length;
  }

  function initializeTooltips() {
    const tooltipTriggerList = [].slice.call(
      document.querySelectorAll('[data-bs-toggle="tooltip"]')
    );
    tooltipTriggerList.map(
      (tooltipTriggerEl) => new bootstrap.Tooltip(tooltipTriggerEl)
    );
  }

  // Group Request Modal Functions (KEEPING ORIGINAL WORKING STRUCTURE)
  function openGroupRequestModal() {
    if (selectedDates.length === 0) {
      showToast('Please select dates first', 'warning');
      return;
    }

    // Use the existing modal from group-request-modal.ejs
    populateModalDates();
    const modal = new bootstrap.Modal(
      document.getElementById('groupRequestModal')
    );
    modal.show();
  }

  function populateModalDates() {
    const container = document.getElementById('selectedDatesList');
    if (!container) {
      console.error('selectedDatesList container not found');
      return;
    }

    container.innerHTML = '';

    selectedDates.forEach((dateObj, index) => {
      const date = new Date(dateObj.date);
      const dateStr = date.toLocaleDateString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      });

      const dateRow = document.createElement('div');
      dateRow.className = 'row mb-2 align-items-center';
      dateRow.innerHTML = `
        <div class="col-md-6">
          <span class="fw-bold">${dateStr}</span>
        </div>
        <div class="col-md-4">
          <select class="form-select form-select-sm" onchange="updateDateType(${index}, this.value)">
            <option value="REQ_DO" ${dateObj.type === 'REQ_DO' ? 'selected' : ''}>Full Day Off</option>
            <option value="PM_OFF" ${dateObj.type === 'PM_OFF' ? 'selected' : ''}>PM Off</option>
            <option value="AM_OFF" ${dateObj.type === 'AM_OFF' ? 'selected' : ''}>AM Off</option>
            <option value="FLIGHT" ${dateObj.type === 'FLIGHT' ? 'selected' : ''}>Flight</option>
          </select>
        </div>
        <div class="col-md-2">
          <input 
            type="text" 
            class="form-control form-control-sm" 
            placeholder="TB###"
            value="${dateObj.flightNumber || ''}"
            ${dateObj.type === 'FLIGHT' ? '' : 'disabled'}
            onchange="updateFlightNumber(${index}, this.value)"
          />
        </div>
      `;

      container.appendChild(dateRow);
    });
  }

  // Global functions for modal (KEEPING ORIGINAL WORKING STRUCTURE)
  window.updateDateType = function (index, newType) {
    selectedDates[index].type = newType;
    if (newType === 'FLIGHT') {
      selectedDates[index].flightNumber =
        selectedDates[index].flightNumber || '';
    } else {
      delete selectedDates[index].flightNumber;
    }
    populateModalDates();
  };

  window.updateFlightNumber = function (index, flightNumber) {
    selectedDates[index].flightNumber = flightNumber;
  };

  async function submitGroupRequest() {
    const customMessage = document
      .getElementById('customMessage')
      ?.value.trim();

    // Validate flight numbers
    for (const dateObj of selectedDates) {
      if (dateObj.type === 'FLIGHT') {
        const flightNumber = dateObj.flightNumber?.trim();
        if (!flightNumber || !flightNumber.startsWith('TB')) {
          showToast(
            'Flight requests must have a valid TB flight number',
            'error'
          );
          return;
        }
        dateObj.flightNumber = flightNumber;
      }
    }

    // Validate consecutive dates
    if (!validateConsecutiveDates(selectedDates.map((d) => d.date))) {
      showToast('Selected dates must be consecutive', 'error');
      return;
    }

    if (selectedDates.length === 0) return;

    try {
      const response = await fetch('/api/requests/group', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          dates: selectedDates,
          customMessage: customMessage || null,
        }),
      });

      const result = await response.json();

      if (result.success) {
        // Close modal
        const modal = bootstrap.Modal.getInstance(
          document.getElementById('groupRequestModal')
        );
        modal.hide();

        // Clear selection
        selectedDates = [];
        calendar.updateDateSelection();
        calendar.updateFloatingButton();

        // Reload data
        await loadExistingRequests();

        showToast(result.message, 'success');
      } else {
        showToast(result.error, 'error');
      }
    } catch (error) {
      console.error('Error creating group request:', error);
      showToast('Failed to create request', 'error');
    }
  }

  // Event Listeners - Fixed initialization
  document.addEventListener('DOMContentLoaded', async () => {
    console.log('üìÖ Calendar initialization started...');

    try {
      // Initialize calendar first
      calendar = new CalendarManager();
      console.log('‚úÖ Calendar manager created');

      // Load existing requests
      await loadExistingRequests();
      console.log('‚úÖ Existing requests loaded');

      // Generate initial calendar display
      calendar.generateCalendar();
      console.log('‚úÖ Calendar generated');

      // Setup event listeners AFTER calendar is ready
      setupEventListeners();
      console.log('‚úÖ Event listeners setup complete');
    } catch (error) {
      console.error('‚ùå Calendar initialization failed:', error);
      showToast('Failed to initialize calendar', 'error');
    }
  });

  function setupEventListeners() {
    // Create request button
    const createBtn = document.getElementById('createRequestBtn');
    if (createBtn) {
      createBtn.addEventListener('click', openGroupRequestModal);
      console.log('‚úÖ Create button listener added');
    }

    // Month navigation - ensure buttons exist before adding listeners
    const prevBtn = document.getElementById('prevMonthBtn');
    const nextBtn = document.getElementById('nextMonthBtn');

    if (prevBtn) {
      prevBtn.addEventListener('click', () => {
        console.log('üîÑ Previous month clicked');
        if (calendar) {
          calendar.navigatePrevious();
        }
      });
      console.log('‚úÖ Previous button listener added');
    } else {
      console.warn('‚ö†Ô∏è Previous month button not found');
    }

    if (nextBtn) {
      nextBtn.addEventListener('click', () => {
        console.log('üîÑ Next month clicked');
        if (calendar) {
          calendar.navigateNext();
        }
      });
      console.log('‚úÖ Next button listener added');
    } else {
      console.warn('‚ö†Ô∏è Next month button not found');
    }

    // Modal event listeners
    document.addEventListener('click', (e) => {
      if (e.target.id === 'submitGroupRequest') {
        submitGroupRequest();
      }
    });

    // Clear form when modal is hidden
    document.addEventListener('hidden.bs.modal', (e) => {
      if (e.target.id === 'groupRequestModal') {
        document.getElementById('groupRequestForm')?.reset();
        const customMessageField = document.getElementById('customMessage');
        if (customMessageField) {
          customMessageField.value = '';
        }
      }
    });
  }

  // Utility Functions
  function formatDateForDisplay(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
    });
  }

  function validateConsecutiveDates(dates) {
    if (dates.length <= 1) return true;

    const sortedDates = dates.sort();

    for (let i = 1; i < sortedDates.length; i++) {
      const prevDate = new Date(sortedDates[i - 1]);
      const currentDate = new Date(sortedDates[i]);
      const dayDiff = (currentDate - prevDate) / (1000 * 60 * 60 * 24);

      if (dayDiff !== 1) {
        return false;
      }
    }

    return true;
  }

  // Toast notification function
  function showToast(message, type = 'info') {
    // Create toast container if it doesn't exist
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.className =
        'toast-container position-fixed top-0 end-0 p-3';
      toastContainer.style.zIndex = '1050';
      document.body.appendChild(toastContainer);
    }

    // Create toast element
    const toastId = 'toast-' + Date.now();
    const toastHTML = `
      <div id="${toastId}" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header">
          <i class="bi bi-${type === 'success' ? 'check-circle' : type === 'error' ? 'x-circle' : 'info-circle'} me-2 text-${type === 'success' ? 'success' : type === 'error' ? 'danger' : 'primary'}"></i>
          <strong class="me-auto">TUIfly</strong>
          <small>now</small>
          <button type="button" class="btn-close" data-bs-dismiss="toast"></button>
        </div>
        <div class="toast-body">
          ${message}
        </div>
      </div>
    `;

    toastContainer.insertAdjacentHTML('beforeend', toastHTML);

    // Initialize and show the toast
    const toastElement = document.getElementById(toastId);
    const toast = new bootstrap.Toast(toastElement, {
      autohide: true,
      delay: type === 'error' ? 5000 : 3000,
    });

    toast.show();

    // Remove toast element after it's hidden
    toastElement.addEventListener('hidden.bs.toast', () => {
      toastElement.remove();
    });
  }
</script>
