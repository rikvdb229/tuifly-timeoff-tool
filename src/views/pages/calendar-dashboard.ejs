<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="min-advance-days"
      content="<%= process.env.MIN_ADVANCE_DAYS || 60 %>"
    />
    <meta
      name="max-advance-days"
      content="<%= process.env.MAX_ADVANCE_DAYS || 120 %>"
    />
    <meta
      name="max-days-per-request"
      content="<%= process.env.MAX_DAYS_PER_REQUEST || 4 %>"
    />
    <title>TUIfly Time-Off Calendar</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css"
      rel="stylesheet"
    />
    <style>
      :root {
        --tuifly-blue: #007bff;
        --tuifly-yellow: #ffc107;
        --pending-color: #fff3cd;
        --approved-color: #d1edff;
        --denied-color: #f8d7da;
        --selected-color: #e3f2fd;
        --unavailable-color: #f8f9fa;
      }

      body {
        background-color: #f8f9fa;
      }

      .navbar {
        background: linear-gradient(
          135deg,
          var(--tuifly-blue) 0%,
          #0056b3 100%
        );
      }

      /* Statistics Cards */
      .stats-card {
        transition: transform 0.2s ease-in-out;
        border: none;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .stats-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      /* Calendar Styles */
      .calendar-container {
        background: white;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        padding: 20px;
        margin-bottom: 20px;
      }

      .month-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .month-container {
        border: 1px solid #dee2e6;
        border-radius: 8px;
        overflow: hidden;
      }

      .month-header {
        background: var(--tuifly-blue);
        color: white;
        padding: 10px;
        text-align: center;
        font-weight: bold;
      }

      .weekday-header {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        background-color: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
      }

      .weekday {
        padding: 8px 4px;
        text-align: center;
        font-weight: bold;
        font-size: 0.85rem;
        color: #6c757d;
      }

      .days-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
      }

      .day-cell {
        aspect-ratio: 1;
        border: 1px solid #e9ecef;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: all 0.2s ease;
        min-height: 45px;
      }

      .day-cell:hover:not(.unavailable) {
        background-color: #e3f2fd;
        transform: scale(1.05);
      }

      .day-number {
        font-size: 0.9rem;
        font-weight: 500;
        z-index: 2;
      }

      .day-request {
        font-size: 0.7rem;
        font-weight: bold;
        padding: 1px 3px;
        border-radius: 3px;
        margin-top: 2px;
        z-index: 2;
      }

      /* Day States */
      .day-cell.unavailable {
        background-color: var(--unavailable-color);
        color: #adb5bd;
        cursor: not-allowed;
      }

      .day-cell.other-month {
        color: #adb5bd;
      }

      .day-cell.weekend {
        background-color: #f8f9fa;
      }

      .day-cell.selected {
        background-color: var(--selected-color) !important;
        border: 2px solid var(--tuifly-blue);
        transform: scale(1.05);
      }

      .day-cell.conflict {
        background-color: #f8d7da !important;
        border: 2px solid #dc3545;
      }

      /* Request Status Colors */
      .request-pending {
        background-color: var(--tuifly-yellow);
        color: #856404;
      }

      .request-approved {
        background-color: #28a745;
        color: white;
      }

      .request-denied {
        background-color: #dc3545;
        color: white;
      }

      /* Floating Button */
      .floating-button {
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 1000;
        border-radius: 50px;
        padding: 15px 25px;
        font-weight: bold;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        opacity: 0;
        transform: translateY(100px);
        transition: all 0.3s ease;
      }

      .floating-button.show {
        opacity: 1;
        transform: translateY(0);
      }

      /* Toast Notifications */
      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
      }

      .toast {
        min-width: 300px;
      }

      /* Tooltip */
      .tooltip {
        pointer-events: none;
      }

      /* Mobile Responsiveness */
      @media (max-width: 768px) {
        .month-grid {
          grid-template-columns: 1fr;
        }

        .day-cell {
          min-height: 40px;
        }

        .floating-button {
          bottom: 20px;
          right: 20px;
          padding: 12px 20px;
        }

        .stats-row {
          margin-bottom: 20px;
        }

        /* Mobile navigation adjustments */
        .calendar-container .d-flex.justify-content-between {
          flex-direction: column;
          gap: 15px;
        }

        .calendar-container .d-flex.align-items-center.gap-3 {
          flex-wrap: wrap;
          justify-content: center;
        }

        #currentMonthDisplay {
          font-size: 0.9rem;
          margin: 0 10px !important;
        }

        .btn-sm {
          padding: 4px 8px;
          font-size: 0.8rem;
        }
      }

      /* Loading States */
      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid var(--tuifly-blue);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>
  </head>
  <body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark">
      <div class="container">
        <a class="navbar-brand" href="/">
          <i class="bi bi-airplane"></i> TUIfly Time-Off Calendar
        </a>
        <div class="navbar-nav ms-auto">
          <span class="nav-link text-white">
            <i class="bi bi-person-circle"></i> Rik (RVB)
          </span>
        </div>
      </div>
    </nav>

    <div class="container-fluid mt-4">
      <!-- Statistics Cards -->
      <div class="row stats-row mb-4">
        <div class="col-md-3 col-6 mb-3">
          <div class="card stats-card bg-warning text-dark">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h5 class="card-title mb-1">Pending</h5>
                  <h3 id="pendingCount" class="mb-0">
                    <div class="loading"></div>
                  </h3>
                </div>
                <i class="bi bi-clock-history fs-1 opacity-75"></i>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-3 col-6 mb-3">
          <div class="card stats-card bg-success text-white">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h5 class="card-title mb-1">Approved</h5>
                  <h3 id="approvedCount" class="mb-0">
                    <div class="loading"></div>
                  </h3>
                </div>
                <i class="bi bi-check-circle fs-1 opacity-75"></i>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-3 col-6 mb-3">
          <div class="card stats-card bg-danger text-white">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h5 class="card-title mb-1">Denied</h5>
                  <h3 id="deniedCount" class="mb-0">
                    <div class="loading"></div>
                  </h3>
                </div>
                <i class="bi bi-x-circle fs-1 opacity-75"></i>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-3 col-6 mb-3">
          <div class="card stats-card bg-info text-white">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h5 class="card-title mb-1">Total</h5>
                  <h3 id="totalCount" class="mb-0">
                    <div class="loading"></div>
                  </h3>
                </div>
                <i class="bi bi-calendar3 fs-1 opacity-75"></i>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Calendar Container -->
      <div class="calendar-container">
        <div class="d-flex justify-content-between align-items-center mb-3">
          <h4 class="mb-0">
            <i class="bi bi-calendar-week text-primary"></i>
            Request Calendar
          </h4>
          <div class="d-flex align-items-center gap-3">
            <!-- Month Navigation -->
            <div class="d-flex align-items-center gap-2">
              <button id="prevMonthBtn" class="btn btn-outline-primary btn-sm">
                <i class="bi bi-chevron-left"></i> Previous
              </button>
              <span id="currentMonthDisplay" class="fw-bold mx-2"
                >Loading...</span
              >
              <button id="nextMonthBtn" class="btn btn-outline-primary btn-sm">
                Next <i class="bi bi-chevron-right"></i>
              </button>
            </div>

            <!-- Legend -->
            <div class="d-flex gap-3">
              <div class="d-flex align-items-center">
                <div
                  class="request-pending me-2"
                  style="width: 20px; height: 15px; border-radius: 3px"
                ></div>
                <small>Pending</small>
              </div>
              <div class="d-flex align-items-center">
                <div
                  class="request-approved me-2"
                  style="width: 20px; height: 15px; border-radius: 3px"
                ></div>
                <small>Approved</small>
              </div>
              <div class="d-flex align-items-center">
                <div
                  class="request-denied me-2"
                  style="width: 20px; height: 15px; border-radius: 3px"
                ></div>
                <small>Denied</small>
              </div>
            </div>
          </div>
        </div>

        <div id="calendarGrid" class="month-grid">
          <div class="text-center p-4">
            <div class="loading mb-3"></div>
            <p>Loading calendar...</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Floating Make Request Button -->
    <button id="makeRequestBtn" class="btn btn-primary floating-button">
      <i class="bi bi-plus-circle me-2"></i>
      <span id="requestBtnText">Make Request</span>
    </button>

    <!-- Group Request Modal -->
    <div class="modal fade" id="groupRequestModal" tabindex="-1">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">
              <i class="bi bi-calendar-plus"></i> Create Time-Off Request
            </h5>
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="modal"
            ></button>
          </div>
          <div class="modal-body">
            <form id="groupRequestForm">
              <div class="alert alert-info">
                <strong>Selected Dates:</strong>
                <span id="selectedDatesDisplay"></span>
              </div>

              <div id="daysContainer">
                <!-- Dynamic day entries will be inserted here -->
              </div>

              <div class="mb-3">
                <label for="customMessage" class="form-label">
                  <i class="bi bi-chat-text"></i> Custom Message (Optional)
                </label>
                <textarea
                  class="form-control"
                  id="customMessage"
                  name="customMessage"
                  rows="3"
                  placeholder="e.g., Birthday party, Wedding, BBQ with friends..."
                ></textarea>
              </div>
            </form>
          </div>
          <div class="modal-footer">
            <button
              type="button"
              class="btn btn-secondary"
              data-bs-dismiss="modal"
            >
              <i class="bi bi-x-circle"></i> Cancel
            </button>
            <button
              type="button"
              class="btn btn-primary"
              id="submitGroupRequest"
            >
              <i class="bi bi-check-circle"></i> Submit Request
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      // Configuration
      const CONFIG = {
        MIN_ADVANCE_DAYS:
          parseInt(
            document.querySelector('meta[name="min-advance-days"]')?.content
          ) || 60,
        MAX_ADVANCE_DAYS:
          parseInt(
            document.querySelector('meta[name="max-advance-days"]')?.content
          ) || 120,
        MAX_DAYS_PER_REQUEST:
          parseInt(
            document.querySelector('meta[name="max-days-per-request"]')?.content
          ) || 4,
        REQUEST_TYPES: {
          REQ_DO: 'W',
          PM_OFF: 'PM',
          AM_OFF: 'AM',
          FLIGHT: 'FL',
        },
      };

      // Global State
      let selectedDates = [];
      let existingRequests = [];
      let calendarData = {};

      // Calendar Management
      class CalendarManager {
        constructor() {
          this.today = new Date();
          this.minDate = this.addDays(this.today, CONFIG.MIN_ADVANCE_DAYS);
          this.maxDate = this.addDays(this.today, CONFIG.MAX_ADVANCE_DAYS);

          // Allow viewing past requests - start from 3 months before today
          this.viewMinDate = this.addDays(this.today, -90);
          this.viewMaxDate = this.maxDate;

          this.currentViewStart = new Date(
            this.minDate.getFullYear(),
            this.minDate.getMonth(),
            1
          );
          this.monthsToShow = 3;
        }

        addDays(date, days) {
          const result = new Date(date);
          result.setDate(result.getDate() + days);
          return result;
        }

        getMonthsToDisplay() {
          const months = [];
          let current = new Date(this.currentViewStart);

          for (let i = 0; i < this.monthsToShow; i++) {
            months.push(new Date(current));
            current.setMonth(current.getMonth() + 1);
          }

          return months;
        }

        canNavigatePrevious() {
          const previousMonth = new Date(this.currentViewStart);
          previousMonth.setMonth(previousMonth.getMonth() - 1);
          const viewMinMonth = new Date(
            this.viewMinDate.getFullYear(),
            this.viewMinDate.getMonth(),
            1
          );
          return previousMonth >= viewMinMonth;
        }

        canNavigateNext() {
          const lastDisplayedMonth = new Date(this.currentViewStart);
          lastDisplayedMonth.setMonth(
            lastDisplayedMonth.getMonth() + this.monthsToShow - 1
          );
          const viewMaxMonth = new Date(
            this.viewMaxDate.getFullYear(),
            this.viewMaxDate.getMonth(),
            1
          );
          return lastDisplayedMonth < viewMaxMonth;
        }

        navigatePrevious() {
          if (this.canNavigatePrevious()) {
            this.currentViewStart.setMonth(
              this.currentViewStart.getMonth() - 1
            );
            this.generateCalendar();
            this.updateNavigationButtons();
          }
        }

        navigateNext() {
          if (this.canNavigateNext()) {
            this.currentViewStart.setMonth(
              this.currentViewStart.getMonth() + 1
            );
            this.generateCalendar();
            this.updateNavigationButtons();
          }
        }

        updateNavigationButtons() {
          const prevBtn = document.getElementById('prevMonthBtn');
          const nextBtn = document.getElementById('nextMonthBtn');
          const currentDisplay = document.getElementById('currentMonthDisplay');

          prevBtn.disabled = !this.canNavigatePrevious();
          nextBtn.disabled = !this.canNavigateNext();

          // Update current month display
          const months = this.getMonthsToDisplay();
          const startMonth = months[0].toLocaleDateString('en-US', {
            month: 'short',
            year: 'numeric',
          });
          const endMonth = months[months.length - 1].toLocaleDateString(
            'en-US',
            { month: 'short', year: 'numeric' }
          );
          currentDisplay.textContent = `${startMonth} - ${endMonth}`;
        }

        isDateAvailable(date) {
          return date >= this.minDate && date <= this.maxDate;
        }

        isWeekend(date) {
          const day = date.getDay();
          return day === 0 || day === 6;
        }

        formatDate(date) {
          return date.toISOString().split('T')[0];
        }

        generateCalendar() {
          const calendarGrid = document.getElementById('calendarGrid');
          calendarGrid.innerHTML = '';

          const months = this.getMonthsToDisplay();
          const allDatesInView = new Set();

          // First pass: collect all dates that will be displayed
          months.forEach((monthStart) => {
            const firstDay = new Date(
              monthStart.getFullYear(),
              monthStart.getMonth(),
              1
            );
            const lastDay = new Date(
              monthStart.getFullYear(),
              monthStart.getMonth() + 1,
              0
            );
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - firstDay.getDay());

            for (let i = 0; i < 42; i++) {
              const currentDate = new Date(startDate);
              currentDate.setDate(startDate.getDate() + i);
              allDatesInView.add(this.formatDate(currentDate));
            }
          });

          // Second pass: create month containers, only showing dates that belong to each month
          months.forEach((monthStart) => {
            const monthContainer = this.createMonthContainer(
              monthStart,
              allDatesInView
            );
            calendarGrid.appendChild(monthContainer);
          });

          this.updateNavigationButtons();
          // Restore selection highlighting after calendar regeneration
          this.updateDateSelection();
        }

        createMonthContainer(monthStart, allDatesInView) {
          const monthContainer = document.createElement('div');
          monthContainer.className = 'month-container';

          // Month header
          const monthHeader = document.createElement('div');
          monthHeader.className = 'month-header';
          monthHeader.textContent = monthStart.toLocaleDateString('en-US', {
            month: 'long',
            year: 'numeric',
          });

          // Weekday headers
          const weekdayHeader = document.createElement('div');
          weekdayHeader.className = 'weekday-header';
          ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].forEach((day) => {
            const dayElement = document.createElement('div');
            dayElement.className = 'weekday';
            dayElement.textContent = day;
            weekdayHeader.appendChild(dayElement);
          });

          // Days grid
          const daysGrid = document.createElement('div');
          daysGrid.className = 'days-grid';

          const firstDay = new Date(
            monthStart.getFullYear(),
            monthStart.getMonth(),
            1
          );
          const lastDay = new Date(
            monthStart.getFullYear(),
            monthStart.getMonth() + 1,
            0
          );
          const startDate = new Date(firstDay);
          startDate.setDate(startDate.getDate() - firstDay.getDay());

          for (let i = 0; i < 42; i++) {
            const currentDate = new Date(startDate);
            currentDate.setDate(startDate.getDate() + i);

            // Only create cell if this date belongs to current month or is adjacent and not shown elsewhere
            const isCurrentMonth =
              currentDate.getMonth() === monthStart.getMonth();
            const dateStr = this.formatDate(currentDate);

            let shouldShowDate = false;

            if (isCurrentMonth) {
              shouldShowDate = true;
            } else {
              // Show adjacent month dates only if they don't belong to another displayed month
              const dateMonth = new Date(
                currentDate.getFullYear(),
                currentDate.getMonth(),
                1
              );
              const isInOtherDisplayedMonth = this.getMonthsToDisplay().some(
                (month) =>
                  month.getMonth() === dateMonth.getMonth() &&
                  month.getFullYear() === dateMonth.getFullYear()
              );
              shouldShowDate = !isInOtherDisplayedMonth;
            }

            const dayCell = this.createDayCell(
              currentDate,
              monthStart,
              shouldShowDate
            );
            daysGrid.appendChild(dayCell);
          }

          monthContainer.appendChild(monthHeader);
          monthContainer.appendChild(weekdayHeader);
          monthContainer.appendChild(daysGrid);

          return monthContainer;
        }

        createDayCell(date, monthStart, shouldShowDate) {
          const dayCell = document.createElement('div');
          dayCell.className = 'day-cell';
          dayCell.dataset.date = this.formatDate(date);

          if (!shouldShowDate) {
            dayCell.style.visibility = 'hidden';
            return dayCell;
          }

          // Day number
          const dayNumber = document.createElement('div');
          dayNumber.className = 'day-number';
          dayNumber.textContent = date.getDate();

          // Determine cell state
          const isCurrentMonth = date.getMonth() === monthStart.getMonth();
          const isAvailable = this.isDateAvailable(date);
          const isWeekend = this.isWeekend(date);

          if (!isCurrentMonth) {
            dayCell.classList.add('other-month');
          }

          if (isWeekend) {
            dayCell.classList.add('weekend');
          }

          if (!isAvailable) {
            dayCell.classList.add('unavailable');
          } else {
            dayCell.addEventListener('click', () => this.handleDateClick(date));
          }

          // Check for existing requests
          const existingRequest = this.getExistingRequest(date);
          if (existingRequest) {
            const requestElement = document.createElement('div');
            requestElement.className = `day-request request-${existingRequest.status.toLowerCase()}`;
            requestElement.textContent =
              CONFIG.REQUEST_TYPES[existingRequest.type];

            // Add tooltip
            dayCell.setAttribute('data-bs-toggle', 'tooltip');
            dayCell.setAttribute('data-bs-placement', 'top');
            dayCell.setAttribute(
              'title',
              `${this.formatDate(date)}: ${existingRequest.type} (${existingRequest.status})${
                existingRequest.customMessage
                  ? '\nMessage: ' + existingRequest.customMessage
                  : ''
              }`
            );

            dayCell.appendChild(requestElement);
          }

          dayCell.appendChild(dayNumber);
          return dayCell;
        }

        getExistingRequest(date) {
          const dateStr = this.formatDate(date);
          return existingRequests.find((req) => req.startDate === dateStr);
        }

        handleDateClick(date) {
          if (!this.isDateAvailable(date)) return;

          const dateStr = this.formatDate(date);
          const existingRequest = this.getExistingRequest(date);

          // Check conflicts with pending/approved requests
          if (
            existingRequest &&
            ['PENDING', 'APPROVED'].includes(existingRequest.status)
          ) {
            showToast(
              'Date conflicts with existing ' +
                existingRequest.status.toLowerCase() +
                ' request',
              'error'
            );
            this.clearSelection();
            return;
          }

          // Handle date selection - improved logic for consecutive selection
          if (selectedDates.length === 0) {
            // First date selection
            selectedDates = [dateStr];
            this.updateDateSelection();
          } else {
            // Check if clicking an already selected date (deselect it)
            const dateIndex = selectedDates.indexOf(dateStr);
            if (dateIndex !== -1) {
              // If it's the last selected date, remove it
              if (dateIndex === selectedDates.length - 1) {
                selectedDates.pop();
                this.updateDateSelection();
                return;
              }
              // If it's the first date and we have more, remove all and start fresh
              if (dateIndex === 0) {
                selectedDates = [dateStr];
                this.updateDateSelection();
                return;
              }
              // If it's in the middle, start fresh
              selectedDates = [dateStr];
              this.updateDateSelection();
              return;
            }

            // Check if the new date is consecutive to existing selection
            const selectedDateObjs = selectedDates
              .map((d) => new Date(d))
              .sort((a, b) => a - b);
            const newDate = new Date(dateStr);

            // Check if it extends the current selection consecutively
            const earliestDate = selectedDateObjs[0];
            const latestDate = selectedDateObjs[selectedDateObjs.length - 1];

            const isOneDayBefore =
              newDate.getTime() ===
              earliestDate.getTime() - 24 * 60 * 60 * 1000;
            const isOneDayAfter =
              newDate.getTime() === latestDate.getTime() + 24 * 60 * 60 * 1000;

            if (isOneDayBefore || isOneDayAfter) {
              // Check if we're within the 4-day limit
              if (selectedDates.length >= CONFIG.MAX_DAYS_PER_REQUEST) {
                showToast(
                  `Maximum ${CONFIG.MAX_DAYS_PER_REQUEST} days per request`,
                  'error'
                );
                this.clearSelection();
                return;
              }

              // Add the date and sort the selection
              selectedDates.push(dateStr);
              selectedDates.sort();

              // Validate the entire range for conflicts
              if (this.validateDateRange(selectedDates)) {
                this.updateDateSelection();
              } else {
                // Clear selection if validation failed
                this.clearSelection();
              }
            } else {
              // Not consecutive - start new selection or show error
              if (selectedDates.length === 1) {
                // If we only have one date, try to create a range
                const range = this.generateDateRange(
                  new Date(selectedDates[0]),
                  newDate
                );

                if (range.length > CONFIG.MAX_DAYS_PER_REQUEST) {
                  showToast(
                    `Maximum ${CONFIG.MAX_DAYS_PER_REQUEST} days per request`,
                    'error'
                  );
                  this.clearSelection();
                  return;
                }

                if (this.validateDateRange(range)) {
                  selectedDates = range;
                  this.updateDateSelection();
                } else {
                  this.clearSelection();
                }
              } else {
                // Multiple dates selected, not consecutive - start fresh
                showToast(
                  `Only ${CONFIG.MAX_DAYS_PER_REQUEST} consecutive days allowed. Starting new selection.`,
                  'error'
                );
                selectedDates = [dateStr];
                this.updateDateSelection();
              }
            }
          }
        }

        clearSelection() {
          selectedDates = [];
          this.updateDateSelection();
        }

        generateDateRange(start, end) {
          const dates = [];
          const startDate = start <= end ? start : end;
          const endDate = start <= end ? end : start;

          let current = new Date(startDate);
          while (current <= endDate) {
            dates.push(this.formatDate(current));
            current.setDate(current.getDate() + 1);
          }

          return dates;
        }

        validateDateRange(dates) {
          // Check for conflicts
          for (const dateStr of dates) {
            const existingRequest = existingRequests.find(
              (req) => req.startDate === dateStr
            );
            if (
              existingRequest &&
              ['PENDING', 'APPROVED'].includes(existingRequest.status)
            ) {
              showToast(
                `${dateStr} conflicts with existing ${existingRequest.status.toLowerCase()} request`,
                'error'
              );
              return false;
            }
          }

          // Check consecutiveness
          const sortedDates = dates
            .map((d) => new Date(d))
            .sort((a, b) => a - b);
          for (let i = 1; i < sortedDates.length; i++) {
            const diff =
              (sortedDates[i] - sortedDates[i - 1]) / (1000 * 60 * 60 * 24);
            if (diff !== 1) {
              showToast(
                `Only ${CONFIG.MAX_DAYS_PER_REQUEST} consecutive days allowed`,
                'error'
              );
              return false;
            }
          }

          return true;
        }

        updateDateSelection() {
          // Clear previous selections from all calendar cells
          document.querySelectorAll('.day-cell.selected').forEach((cell) => {
            cell.classList.remove('selected');
          });

          // Apply new selections to all matching cells
          selectedDates.forEach((dateStr) => {
            // Use querySelectorAll to find all cells with this date (should only be one now)
            const cells = document.querySelectorAll(`[data-date="${dateStr}"]`);
            cells.forEach((cell) => {
              if (cell && cell.style.visibility !== 'hidden') {
                cell.classList.add('selected');
              }
            });
          });

          // Update button
          this.updateMakeRequestButton();
        }

        updateMakeRequestButton() {
          const button = document.getElementById('makeRequestBtn');
          const buttonText = document.getElementById('requestBtnText');

          if (selectedDates.length > 0) {
            button.classList.add('show');
            buttonText.textContent = `Make Request (${selectedDates.length} day${selectedDates.length > 1 ? 's' : ''})`;
          } else {
            button.classList.remove('show');
          }
        }
      }

      // Initialize calendar
      const calendar = new CalendarManager();

      // Utility Functions
      function showToast(message, type = 'info') {
        const toastContainer = document.querySelector('.toast-container');
        const toastId = 'toast-' + Date.now();

        const bgClass =
          type === 'error'
            ? 'bg-danger'
            : type === 'success'
              ? 'bg-success'
              : 'bg-info';

        const toastHTML = `
                <div id="${toastId}" class="toast ${bgClass} text-white" role="alert">
                    <div class="toast-body d-flex align-items-center">
                        <i class="bi bi-${type === 'error' ? 'exclamation-triangle' : type === 'success' ? 'check-circle' : 'info-circle'} me-2"></i>
                        ${message}
                    </div>
                </div>
            `;

        toastContainer.insertAdjacentHTML('beforeend', toastHTML);

        const toastElement = document.getElementById(toastId);
        const toast = new bootstrap.Toast(toastElement, { delay: 4000 });

        toast.show();

        toastElement.addEventListener('hidden.bs.toast', () => {
          toastElement.remove();
        });
      }

      function formatDateForDisplay(dateStr) {
        const date = new Date(dateStr);
        return date.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
        });
      }

      // API Functions
      async function loadExistingRequests() {
        try {
          const response = await fetch('/api/requests');
          const data = await response.json();

          if (data.success) {
            existingRequests = data.data;
            updateStatistics(data.data);
            calendar.generateCalendar();
            initializeTooltips();
          }
        } catch (error) {
          console.error('Error loading requests:', error);
          showToast('Failed to load existing requests', 'error');
        }
      }

      function updateStatistics(requests) {
        const pending = requests.filter((r) => r.status === 'PENDING').length;
        const approved = requests.filter((r) => r.status === 'APPROVED').length;
        const denied = requests.filter((r) => r.status === 'DENIED').length;

        document.getElementById('pendingCount').textContent = pending;
        document.getElementById('approvedCount').textContent = approved;
        document.getElementById('deniedCount').textContent = denied;
        document.getElementById('totalCount').textContent = requests.length;
      }

      function initializeTooltips() {
        const tooltipTriggerList = [].slice.call(
          document.querySelectorAll('[data-bs-toggle="tooltip"]')
        );
        tooltipTriggerList.map(
          (tooltipTriggerEl) => new bootstrap.Tooltip(tooltipTriggerEl)
        );
      }

      // Modal Functions
      function openGroupRequestModal() {
        if (selectedDates.length === 0) return;

        // Update selected dates display
        const startDate = selectedDates[0];
        const endDate = selectedDates[selectedDates.length - 1];
        let displayText = formatDateForDisplay(startDate);
        if (selectedDates.length > 1) {
          displayText += ` - ${formatDateForDisplay(endDate)}`;
        }
        document.getElementById('selectedDatesDisplay').textContent =
          displayText;

        // Generate day entries
        const daysContainer = document.getElementById('daysContainer');
        daysContainer.innerHTML = '';

        selectedDates.forEach((dateStr, index) => {
          const dayEntry = createDayEntry(dateStr, index);
          daysContainer.appendChild(dayEntry);
        });

        // Show modal
        const modal = new bootstrap.Modal(
          document.getElementById('groupRequestModal')
        );
        modal.show();
      }

      function createDayEntry(dateStr, index) {
        const date = new Date(dateStr);
        const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
        const dateDisplay = formatDateForDisplay(dateStr);

        const dayEntry = document.createElement('div');
        dayEntry.className = 'mb-3 p-3 border rounded';
        dayEntry.innerHTML = `
                <div class="row align-items-center">
                    <div class="col-md-4">
                        <strong>Day ${index + 1}</strong><br>
                        <small class="text-muted">${dayName}, ${dateDisplay}</small>
                    </div>
                    <div class="col-md-5">
                        <select class="form-select request-type-select" data-date="${dateStr}" required>
                            <option value="REQ_DO" selected>Day Off (REQ_DO)</option>
                            <option value="PM_OFF">PM Off</option>
                            <option value="AM_OFF">AM Off</option>
                            <option value="FLIGHT">Flight Request</option>
                        </select>
                    </div>
                    <div class="col-md-3">
                        <input type="text" class="form-control flight-number-input" 
                               data-date="${dateStr}" placeholder="TB###" 
                               style="display: none;">
                    </div>
                </div>
            `;

        // Add event listener for request type change
        const typeSelect = dayEntry.querySelector('.request-type-select');
        const flightInput = dayEntry.querySelector('.flight-number-input');

        typeSelect.addEventListener('change', () => {
          if (typeSelect.value === 'FLIGHT') {
            flightInput.style.display = 'block';
            flightInput.required = true;
          } else {
            flightInput.style.display = 'none';
            flightInput.required = false;
            flightInput.value = '';
          }
        });

        return dayEntry;
      }

      async function submitGroupRequest() {
        const customMessage = document
          .getElementById('customMessage')
          .value.trim();
        const dates = [];

        // Collect data from form
        selectedDates.forEach((dateStr) => {
          const typeSelect = document.querySelector(
            `.request-type-select[data-date="${dateStr}"]`
          );
          const flightInput = document.querySelector(
            `.flight-number-input[data-date="${dateStr}"]`
          );

          const dateData = {
            date: dateStr,
            type: typeSelect.value,
          };

          if (typeSelect.value === 'FLIGHT') {
            if (!flightInput.value.trim()) {
              showToast(
                'Flight number is required for flight requests',
                'error'
              );
              return;
            }
            if (!flightInput.value.startsWith('TB')) {
              showToast('TUIfly flight numbers must start with TB', 'error');
              return;
            }
            dateData.flightNumber = flightInput.value.trim();
          }

          dates.push(dateData);
        });

        if (dates.length !== selectedDates.length) return; // Validation failed

        try {
          const response = await fetch('/api/requests/group', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              dates,
              customMessage: customMessage || null,
            }),
          });

          const result = await response.json();

          if (result.success) {
            // Close modal
            const modal = bootstrap.Modal.getInstance(
              document.getElementById('groupRequestModal')
            );
            modal.hide();

            // Clear selection
            selectedDates = [];
            calendar.updateDateSelection();

            // Reload data
            await loadExistingRequests();

            showToast(result.message, 'success');
          } else {
            showToast(result.error, 'error');
          }
        } catch (error) {
          console.error('Error creating group request:', error);
          showToast('Failed to create request', 'error');
        }
      }

      // Event Listeners
      document
        .getElementById('makeRequestBtn')
        .addEventListener('click', openGroupRequestModal);
      document
        .getElementById('submitGroupRequest')
        .addEventListener('click', submitGroupRequest);

      // Month navigation event listeners
      document.getElementById('prevMonthBtn').addEventListener('click', () => {
        calendar.navigatePrevious();
      });

      document.getElementById('nextMonthBtn').addEventListener('click', () => {
        calendar.navigateNext();
      });

      // Clear form when modal is hidden
      document
        .getElementById('groupRequestModal')
        .addEventListener('hidden.bs.modal', () => {
          document.getElementById('groupRequestForm').reset();
          document.getElementById('customMessage').value = '';
        });

      // Initialize Application
      document.addEventListener('DOMContentLoaded', async () => {
        await loadExistingRequests();
      });
    </script>
  </body>
</html>
